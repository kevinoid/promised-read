<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Specifications in Mocha</title>
  <meta name="generator" content="Mocha &lt;https://mochajs.org/&gt;" />
  <meta name="license" content="MIT" />
  <meta name="copyright" content="&#169; 2016 Kevin Locke &lt;kevin@kevinlocke.name&gt;" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/highlight.js/9.1.0/styles/github.min.css" />
  <style type="text/css">
section section {
  margin-left: 1em;
}
section section section section {
  margin-left: 0;
}
  </style>
</head>
<body>
  <div class="container">
    <section class="suite">
      <h1>AbortError</h1>
      <dl>
        <dt>sets .message from argument</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const a = new AbortError(testMsg);
assert.strictEqual(a.message, testMsg);</code></pre></dd>
        <dt>can be instantiated without arguments</dt>
        <dd><pre><code>const a = new AbortError();
assert(a.message, &#x27;has default message&#x27;);</code></pre></dd>
        <dt>can be instantiated without new</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const a = AbortError(testMsg);
assert(a instanceof AbortError);
assert.strictEqual(a.message, testMsg);</code></pre></dd>
        <dt>inherits from Error</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const a = new AbortError(testMsg);
assert(a instanceof Error);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>EOFError</h1>
      <dl>
        <dt>sets .message from argument</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const a = new EOFError(testMsg);
assert.strictEqual(a.message, testMsg);</code></pre></dd>
        <dt>can be instantiated without arguments</dt>
        <dd><pre><code>const a = new EOFError();
assert(a.message, &#x27;has default message&#x27;);</code></pre></dd>
        <dt>can be instantiated without new</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const a = EOFError(testMsg);
assert(a instanceof EOFError);
assert.strictEqual(a.message, testMsg);</code></pre></dd>
        <dt>inherits from Error</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const a = new EOFError(testMsg);
assert(a instanceof Error);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>TimeoutError</h1>
      <dl>
        <dt>sets .message from argument</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const a = new TimeoutError(testMsg);
assert.strictEqual(a.message, testMsg);</code></pre></dd>
        <dt>can be instantiated without arguments</dt>
        <dd><pre><code>const a = new TimeoutError();
assert(a.message, &#x27;has default message&#x27;);</code></pre></dd>
        <dt>can be instantiated without new</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const a = TimeoutError(testMsg);
assert(a instanceof TimeoutError);
assert.strictEqual(a.message, testMsg);</code></pre></dd>
        <dt>inherits from Error</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const a = new TimeoutError(testMsg);
assert(a instanceof Error);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>promisedRead</h1>
      <dl>
        <dt>has proper sync/async when loaded after yaku</dt>
        <dd><pre><code>fork(&#x27;./test-bin/after-yaku-ok&#x27;)
  .on(&#x27;error&#x27;, done)
  .on(&#x27;exit&#x27;, (code) =&#x3E; {
    assert.strictEqual(code, 0);
    done();
  });</code></pre></dd>
        <dt>has proper sync/async when loaded before yaku</dt>
        <dd><pre><code>fork(&#x27;./test-bin/before-yaku-ok&#x27;)
  .on(&#x27;error&#x27;, done)
  .on(&#x27;exit&#x27;, (code) =&#x3E; {
    assert.strictEqual(code, 0);
    done();
  });</code></pre></dd>
        <section class="suite">
          <h1>with pre-0.10 streams</h1>
          <dl>
            <section class="suite">
              <h1>.read()</h1>
              <dl>
                <dt>returns a Promise with read data</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
process.nextTick(() =&#x3E; {
  input.write(inputData);
});
return read(input).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});</code></pre></dd>
                <dt>returns a Promise with read object</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = {};
input.write(inputData);
return read(input).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});</code></pre></dd>
                <dt>can read a chunk larger than writes</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, 8).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat([inputData, inputData]));
});
input.write(inputData);
process.nextTick(() =&#x3E; {
  input.write(inputData);
});
return promise;</code></pre></dd>
                <dt>can&#x27;t read a chunk smaller than writes</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, 2).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>can read a chunk smaller than writes w/ .unshift()</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
input.unshift = function(chunk) {
  assert.deepEqual(chunk, inputData.slice(2));
};
const promise = read(input, 2).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.slice(0, 2));
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads a larger chunk if unshift emits error</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = function(chunk) {
  this.emit(&#x27;error&#x27;, new Error(&#x27;test&#x27;));
};
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, 2).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads a larger chunk if unshift throws error</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = function(chunk) {
  throw new Error(&#x27;test&#x27;);
};
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, 2).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>does not expose unshift errors</dt>
                <dd><pre><code>const input = new PassThrough();
input.on(&#x27;error&#x27;, done);
input.unshift = function(chunk) {
  this.emit(&#x27;error&#x27;, new Error(&#x27;test&#x27;));
};
const inputData = Buffer.from(&#x27;test&#x27;);
read(input, 2).then(
  (data) =&#x3E; {
    assert.deepEqual(data, inputData);
    done();
  },
  done
);
input.write(inputData);</code></pre></dd>
                <dt>can short-read due to end</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, 8).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
process.nextTick(() =&#x3E; {
  input.end();
});
return promise;</code></pre></dd>
                <dt>can read an empty Array in objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [];
const promise = read(input).then((data) =&#x3E; {
  assert.strictEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads at most one non-Buffer/string</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [1, 2, 3];
const promise = read(input, 2).then((data) =&#x3E; {
  assert.strictEqual(data, inputData[0]);
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>reads at most one Buffer/string if options.objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [Buffer.from(&#x27;Larry&#x27;), Buffer.from(&#x27;Curly&#x27;)];
const promise = read(input, 2, {objectMode: true}).then((data) =&#x3E; {
  assert.strictEqual(data, inputData[0]);
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>resolves with null when no data is read</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = read(input).then((data) =&#x3E; {
  assert.strictEqual(data, null);
});
input.end();
return promise;</code></pre></dd>
                <dt>does not resolve with null for null &#x27;data&#x27; event</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input).then((data) =&#x3E; {
  assert.strictEqual(data, inputData);
});
input.write(null);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>rejects with stream error</dt>
                <dd><pre><code>const input = new PassThrough();
const errTest = new Error(&#x27;test&#x27;);
const promise = read(input).then(
  sinon.mock().never(),
  (err) =&#x3E; { assert.strictEqual(err, errTest); }
);
input.emit(&#x27;error&#x27;, errTest);
return promise;</code></pre></dd>
                <dt>sets previously read data as .read on error</dt>
                <dd><pre><code>const input = new PassThrough();
const errTest = new Error(&#x27;test&#x27;);
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, 8).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
    assert.deepEqual(err.read, inputData);
  }
);
input.write(inputData, () =&#x3E; {
  input.emit(&#x27;error&#x27;, errTest);
});
return promise;</code></pre></dd>
                <dt>read(0) resolves to null</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const spy = input.read &#x26;&#x26; sinon.spy(input, &#x27;read&#x27;);
const promise = read(input, readArg).then((data) =&#x3E; {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(-1) resolves to null</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const spy = input.read &#x26;&#x26; sinon.spy(input, &#x27;read&#x27;);
const promise = read(input, readArg).then((data) =&#x3E; {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(false) resolves to null</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const spy = input.read &#x26;&#x26; sinon.spy(input, &#x27;read&#x27;);
const promise = read(input, readArg).then((data) =&#x3E; {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(undefined) resolves to data</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const spy = input.read &#x26;&#x26; sinon.spy(input, &#x27;read&#x27;);
const promise = read(input, readArg).then((data) =&#x3E; {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(null) resolves to data</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const spy = input.read &#x26;&#x26; sinon.spy(input, &#x27;read&#x27;);
const promise = read(input, readArg).then((data) =&#x3E; {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(true) resolves to data</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const spy = input.read &#x26;&#x26; sinon.spy(input, &#x27;read&#x27;);
const promise = read(input, readArg).then((data) =&#x3E; {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>does not lose sequential writes</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;Larry\n&#x27;),
  Buffer.from(&#x27;Curly\n&#x27;),
  Buffer.from(&#x27;Moe\n&#x27;)
];
const readData = [];
function readAll(readable) {
  return read(input, 2).then((data) =&#x3E; {
    if (data) {
      readData.push(data);
      return readAll(readable);
    }
    return Buffer.concat(readData);
  });
}
const promise = readAll(input).then((result) =&#x3E; {
  assert.deepEqual(result, Buffer.concat(inputData));
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
input.end();
return promise;</code></pre></dd>
                <dt>does not lose consecutive synchronous writes</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;Larry\n&#x27;),
  Buffer.from(&#x27;Curly\n&#x27;),
  Buffer.from(&#x27;Moe\n&#x27;)
];
const readData = [];
function readAll(readable) {
  return read(input, 2).then((data) =&#x3E; {
    if (data) {
      readData.push(data);
      return readAll(readable);
    }
    return Buffer.concat(readData);
  });
}
const promise = readAll(input).then((result) =&#x3E; {
  assert.deepEqual(result, Buffer.concat(inputData));
});
inputData.forEach((data) =&#x3E; {
  input.emit(&#x27;data&#x27;, data);
});
input.emit(&#x27;end&#x27;);
return promise;</code></pre></dd>
                <dt>returns an instance of options.Promise</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = read(input, {Promise: BBPromise});
assert(promise instanceof BBPromise);</code></pre></dd>
                <dt>does not have .abortRead or .cancelRead by default</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = read(input);
assert.strictEqual(promise.abortRead, undefined);
assert.strictEqual(promise.cancelRead, undefined);</code></pre></dd>
                <dt>supports bluebird 3.x cancellation</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, {Promise: BBPromise}).then(
  () =&#x3E; {
    done(new Error(&#x27;then should not be called&#x27;));
  },
  () =&#x3E; {
    done(new Error(&#x27;catch should not be called&#x27;));
  }
);
promise.cancel();
// Delay so that onCancel is called before write
// See https://github.com/petkaantonov/bluebird/issues/1041
setImmediate(() =&#x3E; {
  input.write(inputData);
  // Delay long enough to ensure mocks are not called
  setImmediate(() =&#x3E; {
    if (input.read) {
      assert.deepEqual(input.read(), inputData);
    }
    done();
  });
});</code></pre></dd>
                <dt>supports bluebird timeout with cancellation</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
read(input, {Promise: BBPromise})
  .timeout(2)
  .then(
    () =&#x3E; {
      done(new Error(&#x27;then should not be called&#x27;));
    },
    (err) =&#x3E; {
      assert.strictEqual(err.name, &#x27;TimeoutError&#x27;);
      if (input.read) {
        // Delay so that onCancel is called before write
        // See https://github.com/petkaantonov/bluebird/issues/1041
        setImmediate(() =&#x3E; {
          input.write(inputData);
          setImmediate(() =&#x3E; {
            assert.deepEqual(input.read(), inputData);
            done();
          });
        });
      } else {
        done();
      }
    }
  );</code></pre></dd>
                <section class="suite">
                  <h1>with options.cancellable</h1>
                  <dl>
                    <dt>has .abortRead and .cancelRead methods</dt>
                    <dd><pre><code>const input = new PassThrough();
const promise = read(input, {cancellable: true});
assert.strictEqual(typeof promise.abortRead, &#x27;function&#x27;);
assert.strictEqual(typeof promise.cancelRead, &#x27;function&#x27;);</code></pre></dd>
                    <dt>supports .cancelable as an alias</dt>
                    <dd><pre><code>const input = new PassThrough();
const promise = read(input, {cancelable: true});
assert.strictEqual(typeof promise.abortRead, &#x27;function&#x27;);
assert.strictEqual(typeof promise.cancelRead, &#x27;function&#x27;);</code></pre></dd>
                    <dt>rejects with AbortError on .abortRead</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, {cancellable: true});
promise.then(
  () =&#x3E; {
    done(new Error(&#x27;then should not be called&#x27;));
  },
  (err) =&#x3E; {
    try {
      assert.strictEqual(err.name, &#x27;AbortError&#x27;);
    } catch (errAssert) {
      done(errAssert);
    }
  }
);
promise.abortRead();
input.write(inputData);
// Delay long enough to ensure data is not read
setImmediate(() =&#x3E; {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                    <dt>does not resolve, reject, or read after .cancelRead</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, {cancellable: true});
promise.then(
  () =&#x3E; {
    done(new Error(&#x27;then should not be called&#x27;));
  },
  () =&#x3E; {
    done(new Error(&#x27;catch should not be called&#x27;));
  }
);
promise.cancelRead();
input.write(inputData);
// Delay long enough to ensure mocks are not called
setImmediate(() =&#x3E; {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                    <dt>does nothing on .abortRead after .cancelRead</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, {cancellable: true});
promise.then(
  () =&#x3E; {
    done(new Error(&#x27;then should not be called&#x27;));
  },
  () =&#x3E; {
    done(new Error(&#x27;catch should not be called&#x27;));
  }
);
promise.cancelRead();
promise.abortRead();
input.write(inputData);
// Delay long enough to ensure mocks are not called
setImmediate(() =&#x3E; {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                    <dt>does nothing on .cancelRead after .abortRead</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, {cancellable: true});
promise.then(
  () =&#x3E; {
    done(new Error(&#x27;then should not be called&#x27;));
  },
  (err) =&#x3E; {
    try {
      assert.strictEqual(err.name, &#x27;AbortError&#x27;);
    } catch (errAssert) {
      done(errAssert);
    }
  }
);
promise.abortRead();
promise.cancelRead();
input.write(inputData);
// Delay long enough to ensure mocks are not called
setImmediate(() =&#x3E; {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>with options.timeout</h1>
                  <dl>
                    <dt>rejects with TimeoutError after timeout ms</dt>
                    <dd><pre><code>const input = new PassThrough();
return read(input, {timeout: 1}).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TimeoutError&#x27;);
  }
);</code></pre></dd>
                    <dt>passes options.timeout of 0 to setTimeout</dt>
                    <dd><pre><code>const input = new PassThrough();
const spy = sinon.spy(global, &#x27;setTimeout&#x27;);
const promise = read(input, {timeout: 0}).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TimeoutError&#x27;);
  }
);
setTimeout.restore();
assert.strictEqual(spy.callCount, 1);
assert.strictEqual(spy.firstCall.args[1], 0);
return promise;</code></pre></dd>
                    <dt>resolves if read completes before timeout ms</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
read(input, {timeout: 1}).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
  // Wait until after timeout to catch unhandled error
  setTimeout(done, 2);
}, done);
input.write(inputData);</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>.readTo()</h1>
              <dl>
                <dt>reads up to (and including) the marker</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;Larry\n&#x27;);
const promise = readTo(input, Buffer.from(&#x27;\n&#x27;)).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) the marker with encoding</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = &#x27;Larry\n&#x27;;
const promise = readTo(input, &#x27;\n&#x27;).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) the marker in objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = 3;
const promise = readTo(input, 3).then((data) =&#x3E; {
  // Note:  readTo result is always an Array in objectMode
  assert.deepEqual(data, [inputData]);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to the marker across writes</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;La&#x27;),
  Buffer.from(&#x27;rry\n&#x27;)
];
const promise = readTo(input, Buffer.from(&#x27;\n&#x27;)).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>reads up to the marker across writes with encoding</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = [
  &#x27;La&#x27;,
  &#x27;rry\n&#x27;
];
const promise = readTo(input, &#x27;\n&#x27;).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.join(&#x27;&#x27;));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>reads up to the marker across writes in objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [1, 2, 3];
const promise = readTo(input, 3).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>does strict equality checks for marker in objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
// Note:  null and undefined are not supported by stream.PassThrough
const inputData = [true, 0, &#x27;&#x27;, false];
const promise = readTo(input, false).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>reads up to the marker split across writes with encoding</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = [
  &#x27;Larry\n&#x27;,
  &#x27;Cur&#x27;,
  &#x27;ly\n&#x27;,
  &#x27;Moe\n&#x27;
];
const promise = readTo(input, &#x27;Curly\n&#x27;).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.slice(0, 3).join(&#x27;&#x27;));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>may return data after the marker w/o .unshift</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = undefined;
const inputData = Buffer.from(&#x27;Larry\nCurly&#x27;);
const promise = readTo(input, &#x27;\n&#x27;).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.slice(0, data.length));
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>does not read past the marker in objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [1, 2, 3, 4, 5];
const promise = readTo(input, 3).then((data) =&#x3E; {
  const afterMarker = inputData.indexOf(3) + 1;
  assert.deepEqual(data, inputData.slice(0, afterMarker));
  if (input.read) {
    const expectData = inputData.slice(afterMarker);
    while (expectData.length &#x3E; 0) {
      assert.deepEqual(input.read(), expectData.shift());
    }
  }
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>stops reading after first write for 0-length marker</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = undefined;
const inputData = [
  Buffer.from(&#x27;Larry\n&#x27;),
  Buffer.from(&#x27;Curly\n&#x27;),
  Buffer.from(&#x27;Moe\n&#x27;)
];
const promise = readTo(input, &#x27;&#x27;).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat(inputData).slice(0, data.length));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>treats strings as objects if options.objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [&#x27;Larry&#x27;, &#x27;Curly&#x27;, &#x27;Moe&#x27;];
const promise = readTo(input, &#x27;Moe&#x27;, {objectMode: true})
  .then((data) =&#x3E; {
    assert.deepEqual(data, inputData);
  });
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>can recognize objectMode late</dt>
                <dd><pre><code>// readTo expects a stream of Buffer objects until it reads a string
// at which point it realizes the stream is in objectMode and must
// recover gracefully.
const input = new PassThrough({objectMode: true});
const inputData = [Buffer.from(&#x27;test1&#x27;), &#x27;test2&#x27;];
const promise = readTo(input, inputData[1]).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>can read null from &#x27;data&#x27; events</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const promise = readTo(input, null).then((data) =&#x3E; {
  assert(Array.isArray(data));
  assert.strictEqual(data.length, 1);
  assert.strictEqual(data[0], null);
});
input.write(null);
return promise;</code></pre></dd>
                <dt>sets previously read data as .read on error</dt>
                <dd><pre><code>const input = new PassThrough();
const errTest = new Error(&#x27;test&#x27;);
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
    assert.deepEqual(err.read, inputData);
  }
);
input.write(inputData, () =&#x3E; {
  input.emit(&#x27;error&#x27;, errTest);
});
return promise;</code></pre></dd>
                <dt>rejects with EOFError when no data is read</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = readTo(input, &#x27;\n&#x27;).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;EOFError&#x27;);
  }
);
input.end();
return promise;</code></pre></dd>
                <dt>sets previously read data as .read on EOFError</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;EOFError&#x27;);
    assert.deepEqual(err.read, inputData);
  }
);
input.end(inputData);
return promise;</code></pre></dd>
                <dt>resolves with null when no data if options.endOK</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = readTo(input, &#x27;\n&#x27;, {endOK: true}).then((data) =&#x3E; {
  assert.strictEqual(data, null);
});
input.end();
return promise;</code></pre></dd>
                <dt>resolves with data previously read data if options.endOK</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;, {endOK: true}).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.end(inputData);
return promise;</code></pre></dd>
                <dt>without unshift, sets read data as .read on .abortRead</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = undefined;
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;, {cancellable: true});
input.write(inputData);
process.nextTick(() =&#x3E; {
  promise.abortRead();
});
return promise.then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;AbortError&#x27;);
    assert.deepEqual(err.read, inputData);
  }
);</code></pre></dd>
                <dt>without unshift, returns read data from .cancelRead</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = undefined;
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;, {cancellable: true});
input.write(inputData);
process.nextTick(() =&#x3E; {
  assert.deepEqual(promise.cancelRead(), inputData);
  done();
});</code></pre></dd>
                <dt>without unshift, sets read data as .read on timeout</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = undefined;
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;, {timeout: 1});
input.write(inputData);
return promise.then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TimeoutError&#x27;);
    assert.deepEqual(err.read, inputData);
  }
);</code></pre></dd>
                <section class="suite">
                  <h1>uses result indexOf conversions</h1>
                  <dl>
                    <dt>string marker in Buffer</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;Larry\n&#x27;);
const promise = readTo(input, &#x27;\n&#x27;).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                    <dt>character code marker in Buffer</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;Larry\n&#x27;);
const promise = readTo(input, &#x27;\n&#x27;.charCodeAt(0)).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                    <dt>Buffer marker in string</dt>
                    <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = &#x27;Larry\n&#x27;;
const promise = readTo(input, Buffer.from(&#x27;\n&#x27;)).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                    <dt>rejects with TypeError on type mismatch</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;Larry\n&#x27;);
const promise = readTo(input, true).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TypeError&#x27;);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>.readToEnd()</h1>
              <dl>
                <dt>reads to stream end</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;Larry\n&#x27;),
  Buffer.from(&#x27;Curly\n&#x27;),
  Buffer.from(&#x27;Moe\n&#x27;)
];
const promise = readToEnd(input).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData, input.end.bind(input));
return promise;</code></pre></dd>
                <dt>reads to stream end (encoded)</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = [
  &#x27;Larry\n&#x27;,
  &#x27;Curly\n&#x27;,
  &#x27;Moe\n&#x27;
];
const promise = readToEnd(input).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.join(&#x27;&#x27;));
});
writeEachTo(input, inputData, input.end.bind(input));
return promise;</code></pre></dd>
                <dt>reads to stream end (objectMode)</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [0, 1, 2, 3, 4];
const promise = readToEnd(input).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
writeEachTo(input, inputData, input.end.bind(input));
return promise;</code></pre></dd>
                <dt>resolves with null when no data</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = readToEnd(input).then((data) =&#x3E; {
  assert.strictEqual(data, null);
});
input.end();
return promise;</code></pre></dd>
                <dt>rejects with stream error</dt>
                <dd><pre><code>const input = new PassThrough();
const errTest = new Error(&#x27;test&#x27;);
const promise = readToEnd(input).then(
  sinon.mock().never(),
  (err) =&#x3E; { assert.strictEqual(err, errTest); }
);
input.emit(&#x27;error&#x27;, errTest);
return promise;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>.readToMatch()</h1>
              <dl>
                <dt>reads up to (and including) a RegExp</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = &#x27;Larry\n&#x27;;
const promise = readToMatch(input, /\n/g).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) a non-global RegExp</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = &#x27;Larry\n&#x27;;
const promise = readToMatch(input, /\n/).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) a string expression</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = &#x27;Larry\n&#x27;;
const promise = readToMatch(input, &#x27;\n&#x27;).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) a match split across writes</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = [
  &#x27;Larry\n&#x27;,
  &#x27;Cur&#x27;,
  &#x27;ly\n&#x27;,
  &#x27;Moe\n&#x27;
];
const promise = readToMatch(input, /Curly\n/g).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.slice(0, 3).join(&#x27;&#x27;));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>optimizes search from options.maxMatchLen</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = [
  &#x27;Larry\n&#x27;,
  &#x27;Cur&#x27;,
  &#x27;ly\n&#x27;,
  &#x27;Moe\n&#x27;
];
const regexp = /Curly\n/g;
const options = {maxMatchLen: 6};
// Note:  We could spy on writes to .lastIndex of regexp, but this would
// rely too much on implementation details (of readToMatch and RegExp).
// Instead, this tests it doesn&#x27;t hurt and coverage shows the codepath.
const promise = readToMatch(input, regexp, options).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.slice(0, 3).join(&#x27;&#x27;));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>rejects with SyntaxError for invalid string expressions</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
return readToMatch(input, &#x27;*&#x27;).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;SyntaxError&#x27;);
  }
);</code></pre></dd>
                <dt>rejects with TypeError for non-string streams</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;Larry\n&#x27;);
const promise = readToMatch(input, /\n/g).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TypeError&#x27;);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>resolves with null when no data if options.endOK</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = readToMatch(input, /\n/g, {endOK: true})
  .then((data) =&#x3E; {
    assert.strictEqual(data, null);
  });
input.end();
return promise;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>.readUntil()</h1>
              <dl>
                <dt>continues reading when negative or non-numeric falsey</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [0, 1, 2, 3, 4];
let callNum = 0;
const returnValues = [undefined, null, false, -5, true];
function until(buffer, chunk) {
  assert(Array.isArray(buffer));
  assert(typeof chunk === &#x27;number&#x27;);
  callNum += 1;
  return returnValues[callNum - 1];
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>stops reading on true</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
function until(buffer, chunk) {
  return true;
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>stops reading if matches length</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
function until(buffer, chunk) {
  return buffer.length;
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>stops reading if less than length</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
function until(buffer, chunk) {
  return 2;
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>stops reading on 0</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
function until(buffer, chunk) {
  return 0;
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads to length greater than current buffer</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;test1&#x27;),
  Buffer.from(&#x27;test2&#x27;)
];
function until(buffer, chunk) {
  return inputData[0].length + inputData[1].length;
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>rejects with TypeError for non-numeric/non-boolean</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
function until(buffer, chunk) {
  return {};
}
const promise = readUntil(input, until).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TypeError&#x27;);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>calls the until function on each read</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;Larry\n&#x27;),
  Buffer.from(&#x27;Curly\n&#x27;),
  Buffer.from(&#x27;Moe\n&#x27;)
];
const spy = sinon.spy((buffer, chunk) =&#x3E; {
  assert(Buffer.isBuffer(buffer));
  assert(Buffer.isBuffer(chunk));
  // Note:  No Buffer.equals before Node v0.11.13
  return String(chunk) === String(inputData[inputData.length - 1]);
});
const promise = readUntil(input, spy).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat(inputData));
  assert.strictEqual(spy.callCount, 3);
  spy.getCall(0).calledWithExactly(inputData[0], inputData[0]);
  spy.getCall(1).calledWithExactly(
    Buffer.concat(inputData.slice(0, 2)),
    inputData[1]
  );
  spy.getCall(2).calledWithExactly(
    Buffer.concat(inputData),
    inputData[2]
  );
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>can handle unexpectedly large reads</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;Larry\n&#x27;),
  Buffer.alloc(512)
];
const bigInputData = Buffer.allocUnsafe(4 * 1024);
for (let i = 0; i &#x3C; bigInputData.length; i += 1) {
  bigInputData[i] = i % 256;
}
inputData.push(bigInputData);
// TODO:  Some way to test buffer is a slice of a much larger buffer?
function untilBig(buffer, chunk) {
  return chunk.length === bigInputData.length;
}
const promise = readUntil(input, untilBig).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>treats Buffers as objects if options.objectMode</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;Larry\n&#x27;),
  Buffer.from(&#x27;Curly\n&#x27;),
  Buffer.from(&#x27;Moe\n&#x27;)
];
function until(buffer) {
  assert(Array.isArray(buffer));
  return buffer.length &#x3C; 2 ? -1 : 2;
}
const promise = readUntil(input, until, {objectMode: true})
  .then((data) =&#x3E; {
    assert.deepEqual(data, inputData.slice(0, 2));
  });
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>does not combine Arrays in objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [[&#x27;a&#x27;], [&#x27;b&#x27;], []];
function untilEmpty(arrays) {
  assert(arrays.every(Array.isArray));
  return arrays[arrays.length - 1].length === 0 ? arrays.length : -1;
}
const promise = readUntil(input, untilEmpty).then((data) =&#x3E; {
  assert.strictEqual(data.length, inputData.length);
  data.forEach((array, i) =&#x3E; {
    assert.strictEqual(array, inputData[i]);
  });
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>rejects with EOFError when no data is read</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = readUntil(input, untilNever).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;EOFError&#x27;);
  }
);
input.end();
return promise;</code></pre></dd>
                <dt>sets previously read data as .read on EOFError</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readUntil(input, untilNever).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;EOFError&#x27;);
    assert.deepEqual(err.read, inputData);
  }
);
input.end(inputData);
return promise;</code></pre></dd>
                <dt>rejects with an Error thrown by until</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const errTest = new Error(&#x27;test&#x27;);
function untilExcept(buffer) {
  throw errTest;
}
const promise = readUntil(input, untilExcept).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>rejects with a falsey value thrown by until</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const errTest = null;
function untilExcept(buffer) {
  throw errTest;
}
const promise = readUntil(input, untilExcept).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>without unshift, sets read data as .read on exception</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = undefined;
const inputData = Buffer.from(&#x27;test&#x27;);
const errTest = new Error(&#x27;test&#x27;);
function untilExcept(buffer) {
  throw errTest;
}
const promise = readUntil(input, untilExcept);
input.write(inputData);
return promise.then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
    assert.deepEqual(err.read, inputData);
  }
);</code></pre></dd>
                <dt>rejects with TypeError for non-function until</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = readUntil(input, true).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TypeError&#x27;);
  }
);
return promise;</code></pre></dd>
                <dt>does not cause unhandledRejection for non-function</dt>
                <dd><pre><code>const input = new PassThrough();
const immID = setImmediate(done);
process.once(&#x27;unhandledRejection&#x27;, () =&#x3E; {
  clearImmediate(immID);
  done(new Error(&#x27;unhandledRejection&#x27;));
});
readUntil(input, true).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TypeError&#x27;);
  }
);</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>with 0.10 streams</h1>
          <dl>
            <section class="suite">
              <h1>.read()</h1>
              <dl>
                <dt>returns a Promise with read data</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
process.nextTick(() =&#x3E; {
  input.write(inputData);
});
return read(input).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});</code></pre></dd>
                <dt>returns a Promise with read object</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = {};
input.write(inputData);
return read(input).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});</code></pre></dd>
                <dt>returns a Promise with available data</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
input.write(inputData);
process.nextTick(() =&#x3E; {
  read(input).then(
    (data) =&#x3E; {
      assert.deepEqual(data, inputData);
      done();
    },
    done
  );
});</code></pre></dd>
                <dt>can read a chunk larger than writes</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, 8).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat([inputData, inputData]));
});
input.write(inputData);
process.nextTick(() =&#x3E; {
  input.write(inputData);
});
return promise;</code></pre></dd>
                <dt>can read a chunk smaller than writes</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, 2).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.slice(0, 2));
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>can short-read due to end</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, 8).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
process.nextTick(() =&#x3E; {
  input.end();
});
return promise;</code></pre></dd>
                <dt>can read an empty Array in objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [];
const promise = read(input).then((data) =&#x3E; {
  assert.strictEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads at most one non-Buffer/string</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [1, 2, 3];
const promise = read(input, 2).then((data) =&#x3E; {
  assert.strictEqual(data, inputData[0]);
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>reads at most one Buffer/string if options.objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [Buffer.from(&#x27;Larry&#x27;), Buffer.from(&#x27;Curly&#x27;)];
const promise = read(input, 2, {objectMode: true}).then((data) =&#x3E; {
  assert.strictEqual(data, inputData[0]);
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>resolves with null when no data is read</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = read(input).then((data) =&#x3E; {
  assert.strictEqual(data, null);
});
input.end();
return promise;</code></pre></dd>
                <dt>resolves with null after end for stream.Readable</dt>
                <dd><pre><code>// This only works for proper instances of stream.Readable and is not
// guaranteed to work (due to use of Readable implementation details).
const input = new PassThrough();
input.once(&#x27;end&#x27;, () =&#x3E; {
  process.nextTick(() =&#x3E; {
    read(input).then((data) =&#x3E; {
      assert.strictEqual(data, null);
    }).then(done, done);
  });
});
input.end();
// Note:  Must read after .end() for &#x27;end&#x27; to be emitted
input.read();</code></pre></dd>
                <dt>rejects with stream error</dt>
                <dd><pre><code>const input = new PassThrough();
const errTest = new Error(&#x27;test&#x27;);
const promise = read(input).then(
  sinon.mock().never(),
  (err) =&#x3E; { assert.strictEqual(err, errTest); }
);
input.emit(&#x27;error&#x27;, errTest);
return promise;</code></pre></dd>
                <dt>does not read after error</dt>
                <dd><pre><code>const input = new PassThrough();
const errTest = new Error(&#x27;test&#x27;);
const promise = read(input).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
    assert.notEqual(input.read(), null);
  }
);
input.emit(&#x27;error&#x27;, errTest);
input.write(&#x27;data&#x27;);
return promise;</code></pre></dd>
                <dt>read(0) calls .read and resolves to null</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const spy = input.read &#x26;&#x26; sinon.spy(input, &#x27;read&#x27;);
const promise = read(input, readArg).then((data) =&#x3E; {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(-1) calls .read and resolves to null</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const spy = input.read &#x26;&#x26; sinon.spy(input, &#x27;read&#x27;);
const promise = read(input, readArg).then((data) =&#x3E; {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(false) calls .read and resolves to null</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const spy = input.read &#x26;&#x26; sinon.spy(input, &#x27;read&#x27;);
const promise = read(input, readArg).then((data) =&#x3E; {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(undefined) calls .read and resolves to data</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const spy = input.read &#x26;&#x26; sinon.spy(input, &#x27;read&#x27;);
const promise = read(input, readArg).then((data) =&#x3E; {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(null) calls .read and resolves to data</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const spy = input.read &#x26;&#x26; sinon.spy(input, &#x27;read&#x27;);
const promise = read(input, readArg).then((data) =&#x3E; {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(true) calls .read and resolves to data</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const spy = input.read &#x26;&#x26; sinon.spy(input, &#x27;read&#x27;);
const promise = read(input, readArg).then((data) =&#x3E; {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>can pass an object argument to .read with options</dt>
                <dd><pre><code>const input = new PassThrough();
const readArg = {};
const mock = sinon.mock(input)
  .expects(&#x27;read&#x27;)
  .once()
  .withExactArgs(readArg);
read(input, readArg, {});
mock.verify();</code></pre></dd>
                <dt>does not lose sequential writes</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;Larry\n&#x27;),
  Buffer.from(&#x27;Curly\n&#x27;),
  Buffer.from(&#x27;Moe\n&#x27;)
];
const readData = [];
function readAll(readable) {
  return read(input, 2).then((data) =&#x3E; {
    if (data) {
      readData.push(data);
      return readAll(readable);
    }
    return Buffer.concat(readData);
  });
}
const promise = readAll(input).then((result) =&#x3E; {
  assert.deepEqual(result, Buffer.concat(inputData));
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
input.end();
return promise;</code></pre></dd>
                <dt>returns an instance of options.Promise</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = read(input, {Promise: BBPromise});
assert(promise instanceof BBPromise);</code></pre></dd>
                <dt>does not have .abortRead or .cancelRead by default</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = read(input);
assert.strictEqual(promise.abortRead, undefined);
assert.strictEqual(promise.cancelRead, undefined);</code></pre></dd>
                <dt>supports bluebird 3.x cancellation</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, {Promise: BBPromise}).then(
  () =&#x3E; {
    done(new Error(&#x27;then should not be called&#x27;));
  },
  () =&#x3E; {
    done(new Error(&#x27;catch should not be called&#x27;));
  }
);
promise.cancel();
// Delay so that onCancel is called before write
// See https://github.com/petkaantonov/bluebird/issues/1041
setImmediate(() =&#x3E; {
  input.write(inputData);
  // Delay long enough to ensure mocks are not called
  setImmediate(() =&#x3E; {
    if (input.read) {
      assert.deepEqual(input.read(), inputData);
    }
    done();
  });
});</code></pre></dd>
                <dt>supports bluebird timeout with cancellation</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
read(input, {Promise: BBPromise})
  .timeout(2)
  .then(
    () =&#x3E; {
      done(new Error(&#x27;then should not be called&#x27;));
    },
    (err) =&#x3E; {
      assert.strictEqual(err.name, &#x27;TimeoutError&#x27;);
      if (input.read) {
        // Delay so that onCancel is called before write
        // See https://github.com/petkaantonov/bluebird/issues/1041
        setImmediate(() =&#x3E; {
          input.write(inputData);
          setImmediate(() =&#x3E; {
            assert.deepEqual(input.read(), inputData);
            done();
          });
        });
      } else {
        done();
      }
    }
  );</code></pre></dd>
                <section class="suite">
                  <h1>with options.cancellable</h1>
                  <dl>
                    <dt>has .abortRead and .cancelRead methods</dt>
                    <dd><pre><code>const input = new PassThrough();
const promise = read(input, {cancellable: true});
assert.strictEqual(typeof promise.abortRead, &#x27;function&#x27;);
assert.strictEqual(typeof promise.cancelRead, &#x27;function&#x27;);</code></pre></dd>
                    <dt>supports .cancelable as an alias</dt>
                    <dd><pre><code>const input = new PassThrough();
const promise = read(input, {cancelable: true});
assert.strictEqual(typeof promise.abortRead, &#x27;function&#x27;);
assert.strictEqual(typeof promise.cancelRead, &#x27;function&#x27;);</code></pre></dd>
                    <dt>rejects with AbortError on .abortRead</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, {cancellable: true});
promise.then(
  () =&#x3E; {
    done(new Error(&#x27;then should not be called&#x27;));
  },
  (err) =&#x3E; {
    try {
      assert.strictEqual(err.name, &#x27;AbortError&#x27;);
    } catch (errAssert) {
      done(errAssert);
    }
  }
);
promise.abortRead();
input.write(inputData);
// Delay long enough to ensure data is not read
setImmediate(() =&#x3E; {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                    <dt>does not resolve, reject, or read after .cancelRead</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, {cancellable: true});
promise.then(
  () =&#x3E; {
    done(new Error(&#x27;then should not be called&#x27;));
  },
  () =&#x3E; {
    done(new Error(&#x27;catch should not be called&#x27;));
  }
);
promise.cancelRead();
input.write(inputData);
// Delay long enough to ensure mocks are not called
setImmediate(() =&#x3E; {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                    <dt>does nothing on .abortRead after .cancelRead</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, {cancellable: true});
promise.then(
  () =&#x3E; {
    done(new Error(&#x27;then should not be called&#x27;));
  },
  () =&#x3E; {
    done(new Error(&#x27;catch should not be called&#x27;));
  }
);
promise.cancelRead();
promise.abortRead();
input.write(inputData);
// Delay long enough to ensure mocks are not called
setImmediate(() =&#x3E; {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                    <dt>does nothing on .cancelRead after .abortRead</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = read(input, {cancellable: true});
promise.then(
  () =&#x3E; {
    done(new Error(&#x27;then should not be called&#x27;));
  },
  (err) =&#x3E; {
    try {
      assert.strictEqual(err.name, &#x27;AbortError&#x27;);
    } catch (errAssert) {
      done(errAssert);
    }
  }
);
promise.abortRead();
promise.cancelRead();
input.write(inputData);
// Delay long enough to ensure mocks are not called
setImmediate(() =&#x3E; {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>with options.timeout</h1>
                  <dl>
                    <dt>rejects with TimeoutError after timeout ms</dt>
                    <dd><pre><code>const input = new PassThrough();
return read(input, {timeout: 1}).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TimeoutError&#x27;);
  }
);</code></pre></dd>
                    <dt>passes options.timeout of 0 to setTimeout</dt>
                    <dd><pre><code>const input = new PassThrough();
const spy = sinon.spy(global, &#x27;setTimeout&#x27;);
const promise = read(input, {timeout: 0}).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TimeoutError&#x27;);
  }
);
setTimeout.restore();
assert.strictEqual(spy.callCount, 1);
assert.strictEqual(spy.firstCall.args[1], 0);
return promise;</code></pre></dd>
                    <dt>does not read after timeout</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
read(input, {timeout: 1}).then(
  () =&#x3E; {
    done(new Error(&#x27;then should not be called&#x27;));
  },
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TimeoutError&#x27;);
    input.write(inputData);
    setImmediate(() =&#x3E; {
      assert.deepEqual(input.read(), inputData);
      done();
    });
  }
);</code></pre></dd>
                    <dt>resolves if read completes before timeout ms</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
read(input, {timeout: 1}).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
  // Wait until after timeout to catch unhandled error
  setTimeout(done, 2);
}, done);
input.write(inputData);</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>.readTo()</h1>
              <dl>
                <dt>reads up to (and including) the marker</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;Larry\n&#x27;);
const promise = readTo(input, Buffer.from(&#x27;\n&#x27;)).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) the marker with encoding</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = &#x27;Larry\n&#x27;;
const promise = readTo(input, &#x27;\n&#x27;).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) the marker in objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = 3;
const promise = readTo(input, 3).then((data) =&#x3E; {
  // Note:  readTo result is always an Array in objectMode
  assert.deepEqual(data, [inputData]);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to the marker across writes</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;La&#x27;),
  Buffer.from(&#x27;rry\n&#x27;)
];
const promise = readTo(input, Buffer.from(&#x27;\n&#x27;)).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>reads up to the marker across writes with encoding</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = [
  &#x27;La&#x27;,
  &#x27;rry\n&#x27;
];
const promise = readTo(input, &#x27;\n&#x27;).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.join(&#x27;&#x27;));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>reads up to the marker across writes in objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [1, 2, 3];
const promise = readTo(input, 3).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>does strict equality checks for marker in objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
// Note:  null and undefined are not supported by stream.PassThrough
const inputData = [true, 0, &#x27;&#x27;, false];
const promise = readTo(input, false).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>reads up to the marker split across writes with encoding</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = [
  &#x27;Larry\n&#x27;,
  &#x27;Cur&#x27;,
  &#x27;ly\n&#x27;,
  &#x27;Moe\n&#x27;
];
const promise = readTo(input, &#x27;Curly\n&#x27;).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.slice(0, 3).join(&#x27;&#x27;));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>may return data after the marker w/o .unshift</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = undefined;
const inputData = Buffer.from(&#x27;Larry\nCurly&#x27;);
const promise = readTo(input, &#x27;\n&#x27;).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.slice(0, data.length));
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>does not read past the marker w/ .unshift</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;Larry\nCurly&#x27;);
const promise = readTo(input, &#x27;\n&#x27;).then((data) =&#x3E; {
  const afterMarker = String(inputData).indexOf(&#x27;\n&#x27;) + 1;
  assert.deepEqual(data, inputData.slice(0, afterMarker));
  assert.deepEqual(input.read(), inputData.slice(afterMarker));
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>does not read past the marker in objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [1, 2, 3, 4, 5];
const promise = readTo(input, 3).then((data) =&#x3E; {
  const afterMarker = inputData.indexOf(3) + 1;
  assert.deepEqual(data, inputData.slice(0, afterMarker));
  if (input.read) {
    const expectData = inputData.slice(afterMarker);
    while (expectData.length &#x3E; 0) {
      assert.deepEqual(input.read(), expectData.shift());
    }
  }
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>stops reading after first write for 0-length marker</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = undefined;
const inputData = [
  Buffer.from(&#x27;Larry\n&#x27;),
  Buffer.from(&#x27;Curly\n&#x27;),
  Buffer.from(&#x27;Moe\n&#x27;)
];
const promise = readTo(input, &#x27;&#x27;).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat(inputData).slice(0, data.length));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>returns empty Buffer for 0-length marker w/ unshift</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;Larry\n&#x27;);
const promise = readTo(input, Buffer.alloc(0)).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.alloc(0));
  assert.deepEqual(input.read(), inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>treats strings as objects if options.objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [&#x27;Larry&#x27;, &#x27;Curly&#x27;, &#x27;Moe&#x27;];
const promise = readTo(input, &#x27;Moe&#x27;, {objectMode: true})
  .then((data) =&#x3E; {
    assert.deepEqual(data, inputData);
  });
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>can recognize objectMode late</dt>
                <dd><pre><code>// readTo expects a stream of Buffer objects until it reads a string
// at which point it realizes the stream is in objectMode and must
// recover gracefully.
const input = new PassThrough({objectMode: true});
const inputData = [Buffer.from(&#x27;test1&#x27;), &#x27;test2&#x27;];
const promise = readTo(input, inputData[1]).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>sets previously read data as .read on error</dt>
                <dd><pre><code>const input = new PassThrough();
const errTest = new Error(&#x27;test&#x27;);
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
    assert.deepEqual(err.read, inputData);
  }
);
input.write(inputData, () =&#x3E; {
  input.emit(&#x27;error&#x27;, errTest);
});
return promise;</code></pre></dd>
                <dt>rejects with EOFError when no data is read</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = readTo(input, &#x27;\n&#x27;).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;EOFError&#x27;);
  }
);
input.end();
return promise;</code></pre></dd>
                <dt>sets previously read data as .read on EOFError</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;EOFError&#x27;);
    assert.deepEqual(err.read, inputData);
  }
);
input.end(inputData);
return promise;</code></pre></dd>
                <dt>resolves with null when no data if options.endOK</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = readTo(input, &#x27;\n&#x27;, {endOK: true}).then((data) =&#x3E; {
  assert.strictEqual(data, null);
});
input.end();
return promise;</code></pre></dd>
                <dt>resolves with data previously read data if options.endOK</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;, {endOK: true}).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.end(inputData);
return promise;</code></pre></dd>
                <dt>without unshift, sets read data as .read on .abortRead</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = undefined;
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;, {cancellable: true});
input.write(inputData);
process.nextTick(() =&#x3E; {
  promise.abortRead();
});
return promise.then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;AbortError&#x27;);
    assert.deepEqual(err.read, inputData);
  }
);</code></pre></dd>
                <dt>without unshift, returns read data from .cancelRead</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = undefined;
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;, {cancellable: true});
input.write(inputData);
process.nextTick(() =&#x3E; {
  assert.deepEqual(promise.cancelRead(), inputData);
  done();
});</code></pre></dd>
                <dt>without unshift, sets read data as .read on timeout</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = undefined;
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;, {timeout: 1});
input.write(inputData);
return promise.then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TimeoutError&#x27;);
    assert.deepEqual(err.read, inputData);
  }
);</code></pre></dd>
                <dt>with unshift, unshifts read data on .abortRead</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;, {cancellable: true});
input.write(inputData);
process.nextTick(() =&#x3E; {
  promise.abortRead();
});
return promise.then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;AbortError&#x27;);
    assert.strictEqual(err.read, undefined);
    assert.deepEqual(input.read(), inputData);
  }
);</code></pre></dd>
                <dt>with unshift, unshifts read data on .cancelRead</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;, {cancellable: true});
input.write(inputData);
// Wait until data has been read
process.nextTick(() =&#x3E; {
  promise.cancelRead();
  assert.deepEqual(input.read(), inputData);
  done();
});</code></pre></dd>
                <dt>with unshift, unshifts read data on timeout</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readTo(input, &#x27;\n&#x27;, {timeout: 1});
input.write(inputData);
return promise.then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TimeoutError&#x27;);
    assert.strictEqual(err.read, undefined);
    assert.deepEqual(input.read(), inputData);
  }
);</code></pre></dd>
                <section class="suite">
                  <h1>uses result indexOf conversions</h1>
                  <dl>
                    <dt>string marker in Buffer</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;Larry\n&#x27;);
const promise = readTo(input, &#x27;\n&#x27;).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                    <dt>character code marker in Buffer</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;Larry\n&#x27;);
const promise = readTo(input, &#x27;\n&#x27;.charCodeAt(0)).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                    <dt>Buffer marker in string</dt>
                    <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = &#x27;Larry\n&#x27;;
const promise = readTo(input, Buffer.from(&#x27;\n&#x27;)).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                    <dt>rejects with TypeError on type mismatch</dt>
                    <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;Larry\n&#x27;);
const promise = readTo(input, true).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TypeError&#x27;);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>.readToEnd()</h1>
              <dl>
                <dt>reads to stream end</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;Larry\n&#x27;),
  Buffer.from(&#x27;Curly\n&#x27;),
  Buffer.from(&#x27;Moe\n&#x27;)
];
const promise = readToEnd(input).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData, input.end.bind(input));
return promise;</code></pre></dd>
                <dt>reads to stream end (encoded)</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = [
  &#x27;Larry\n&#x27;,
  &#x27;Curly\n&#x27;,
  &#x27;Moe\n&#x27;
];
const promise = readToEnd(input).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.join(&#x27;&#x27;));
});
writeEachTo(input, inputData, input.end.bind(input));
return promise;</code></pre></dd>
                <dt>reads to stream end (objectMode)</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [0, 1, 2, 3, 4];
const promise = readToEnd(input).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
writeEachTo(input, inputData, input.end.bind(input));
return promise;</code></pre></dd>
                <dt>resolves with null when no data</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = readToEnd(input).then((data) =&#x3E; {
  assert.strictEqual(data, null);
});
input.end();
return promise;</code></pre></dd>
                <dt>rejects with stream error</dt>
                <dd><pre><code>const input = new PassThrough();
const errTest = new Error(&#x27;test&#x27;);
const promise = readToEnd(input).then(
  sinon.mock().never(),
  (err) =&#x3E; { assert.strictEqual(err, errTest); }
);
input.emit(&#x27;error&#x27;, errTest);
return promise;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>.readToMatch()</h1>
              <dl>
                <dt>reads up to (and including) a RegExp</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = &#x27;Larry\n&#x27;;
const promise = readToMatch(input, /\n/g).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) a non-global RegExp</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = &#x27;Larry\n&#x27;;
const promise = readToMatch(input, /\n/).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) a string expression</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = &#x27;Larry\n&#x27;;
const promise = readToMatch(input, &#x27;\n&#x27;).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) a match split across writes</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = [
  &#x27;Larry\n&#x27;,
  &#x27;Cur&#x27;,
  &#x27;ly\n&#x27;,
  &#x27;Moe\n&#x27;
];
const promise = readToMatch(input, /Curly\n/g).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.slice(0, 3).join(&#x27;&#x27;));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>optimizes search from options.maxMatchLen</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
const inputData = [
  &#x27;Larry\n&#x27;,
  &#x27;Cur&#x27;,
  &#x27;ly\n&#x27;,
  &#x27;Moe\n&#x27;
];
const regexp = /Curly\n/g;
const options = {maxMatchLen: 6};
// Note:  We could spy on writes to .lastIndex of regexp, but this would
// rely too much on implementation details (of readToMatch and RegExp).
// Instead, this tests it doesn&#x27;t hurt and coverage shows the codepath.
const promise = readToMatch(input, regexp, options).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.slice(0, 3).join(&#x27;&#x27;));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>rejects with SyntaxError for invalid string expressions</dt>
                <dd><pre><code>const input = new PassThrough({encoding: &#x27;utf8&#x27;});
return readToMatch(input, &#x27;*&#x27;).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;SyntaxError&#x27;);
  }
);</code></pre></dd>
                <dt>rejects with TypeError for non-string streams</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;Larry\n&#x27;);
const promise = readToMatch(input, /\n/g).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TypeError&#x27;);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>resolves with null when no data if options.endOK</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = readToMatch(input, /\n/g, {endOK: true})
  .then((data) =&#x3E; {
    assert.strictEqual(data, null);
  });
input.end();
return promise;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>.readUntil()</h1>
              <dl>
                <dt>continues reading when negative or non-numeric falsey</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [0, 1, 2, 3, 4];
let callNum = 0;
const returnValues = [undefined, null, false, -5, true];
function until(buffer, chunk) {
  assert(Array.isArray(buffer));
  assert(typeof chunk === &#x27;number&#x27;);
  callNum += 1;
  return returnValues[callNum - 1];
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>stops reading on true</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
function until(buffer, chunk) {
  return true;
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>stops reading if matches length</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
function until(buffer, chunk) {
  return buffer.length;
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>stops reading and unshifts if less than length</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
function until(buffer, chunk) {
  return 2;
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.slice(0, 2));
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>stops reading and unshifts for objectMode stream</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [0, 1, 2, 3, 4];
function until(buffer, chunk) {
  return buffer.length === inputData.length - 1 ? 2 : -1;
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, inputData.slice(0, 2));
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>stops reading and unshifts on 0</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
function until(buffer, chunk) {
  return 0;
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.alloc(0));
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>can not unshift once ended</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
function until(buffer, chunk, ended) {
  return ended ? 2 : -1;
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, inputData);
});
input.end(inputData);
return promise;</code></pre></dd>
                <dt>reads to length greater than current buffer</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;test1&#x27;),
  Buffer.from(&#x27;test2&#x27;)
];
function until(buffer, chunk) {
  return inputData[0].length + inputData[1].length;
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>reads to exact length greater than current buffer</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = undefined;
const inputData = [
  Buffer.from(&#x27;test1&#x27;),
  Buffer.from(&#x27;test2&#x27;)
];
function until(buffer, chunk) {
  return (inputData[0].length + inputData[1].length) - 2;
}
const promise = readUntil(input, until).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat(inputData).slice(0, -2));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>rejects with TypeError for non-numeric/non-boolean</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
function until(buffer, chunk) {
  return {};
}
const promise = readUntil(input, until).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TypeError&#x27;);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>unshifts on TypeError due to non-numeric/non-boolean</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
function until(buffer, chunk) {
  return {};
}
const promise = readUntil(input, until).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TypeError&#x27;);
    assert.deepEqual(input.read(), inputData);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>calls the until function on each read</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;Larry\n&#x27;),
  Buffer.from(&#x27;Curly\n&#x27;),
  Buffer.from(&#x27;Moe\n&#x27;)
];
const spy = sinon.spy((buffer, chunk) =&#x3E; {
  assert(Buffer.isBuffer(buffer));
  assert(Buffer.isBuffer(chunk));
  // Note:  No Buffer.equals before Node v0.11.13
  return String(chunk) === String(inputData[inputData.length - 1]);
});
const promise = readUntil(input, spy).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat(inputData));
  assert.strictEqual(spy.callCount, 3);
  spy.getCall(0).calledWithExactly(inputData[0], inputData[0]);
  spy.getCall(1).calledWithExactly(
    Buffer.concat(inputData.slice(0, 2)),
    inputData[1]
  );
  spy.getCall(2).calledWithExactly(
    Buffer.concat(inputData),
    inputData[2]
  );
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>can handle unexpectedly large reads</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;Larry\n&#x27;),
  Buffer.alloc(512)
];
const bigInputData = Buffer.allocUnsafe(4 * 1024);
for (let i = 0; i &#x3C; bigInputData.length; i += 1) {
  bigInputData[i] = i % 256;
}
inputData.push(bigInputData);
// TODO:  Some way to test buffer is a slice of a much larger buffer?
function untilBig(buffer, chunk) {
  return chunk.length === bigInputData.length;
}
const promise = readUntil(input, untilBig).then((data) =&#x3E; {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>treats Buffers as objects if options.objectMode</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = [
  Buffer.from(&#x27;Larry\n&#x27;),
  Buffer.from(&#x27;Curly\n&#x27;),
  Buffer.from(&#x27;Moe\n&#x27;)
];
function until(buffer) {
  assert(Array.isArray(buffer));
  return buffer.length &#x3C; 2 ? -1 : 2;
}
const promise = readUntil(input, until, {objectMode: true})
  .then((data) =&#x3E; {
    assert.deepEqual(data, inputData.slice(0, 2));
  });
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>does not combine Arrays in objectMode</dt>
                <dd><pre><code>const input = new PassThrough({objectMode: true});
const inputData = [[&#x27;a&#x27;], [&#x27;b&#x27;], []];
function untilEmpty(arrays) {
  assert(arrays.every(Array.isArray));
  return arrays[arrays.length - 1].length === 0 ? arrays.length : -1;
}
const promise = readUntil(input, untilEmpty).then((data) =&#x3E; {
  assert.strictEqual(data.length, inputData.length);
  data.forEach((array, i) =&#x3E; {
    assert.strictEqual(array, inputData[i]);
  });
});
inputData.forEach((data) =&#x3E; {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>rejects with EOFError when no data is read</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = readUntil(input, untilNever).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;EOFError&#x27;);
  }
);
input.end();
return promise;</code></pre></dd>
                <dt>sets previously read data as .read on EOFError</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const promise = readUntil(input, untilNever).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;EOFError&#x27;);
    assert.deepEqual(err.read, inputData);
  }
);
input.end(inputData);
return promise;</code></pre></dd>
                <dt>rejects with EOFError after end for stream.Readable</dt>
                <dd><pre><code>// This only works for proper instances of stream.Readable and is not
// guaranteed to work (due to use of Readable implementation details).
const input = new PassThrough();
input.once(&#x27;end&#x27;, () =&#x3E; {
  process.nextTick(() =&#x3E; {
    readUntil(input, untilNever).then(
      sinon.mock().never(),
      (err) =&#x3E; {
        assert.strictEqual(err.name, &#x27;EOFError&#x27;);
      }
    ).then(done, done);
  });
});
input.end();
// Note:  Must read after .end() for &#x27;end&#x27; to be emitted
input.read();</code></pre></dd>
                <dt>rejects with an Error thrown by until</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const errTest = new Error(&#x27;test&#x27;);
function untilExcept(buffer) {
  throw errTest;
}
const promise = readUntil(input, untilExcept).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>rejects with a falsey value thrown by until</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const errTest = null;
function untilExcept(buffer) {
  throw errTest;
}
const promise = readUntil(input, untilExcept).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>does not read after exception</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const inputData2 = Buffer.from(&#x27;test2&#x27;);
const errTest = new Error(&#x27;test&#x27;);
function untilExcept(buffer) {
  throw errTest;
}
readUntil(input, untilExcept).then(
  () =&#x3E; {
    done(new Error(&#x27;then should not be called&#x27;));
  },
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
    // Discard inputData, if it was unshifted
    input.read();
    input.write(inputData2);
    setImmediate(() =&#x3E; {
      assert.deepEqual(input.read(), inputData2);
      done();
    });
  }
);
input.write(inputData);</code></pre></dd>
                <dt>without unshift, sets read data as .read on exception</dt>
                <dd><pre><code>const input = new PassThrough();
input.unshift = undefined;
const inputData = Buffer.from(&#x27;test&#x27;);
const errTest = new Error(&#x27;test&#x27;);
function untilExcept(buffer) {
  throw errTest;
}
const promise = readUntil(input, untilExcept);
input.write(inputData);
return promise.then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
    assert.deepEqual(err.read, inputData);
  }
);</code></pre></dd>
                <dt>with unshift, unshifts read data on exception</dt>
                <dd><pre><code>const input = new PassThrough();
const inputData = Buffer.from(&#x27;test&#x27;);
const errTest = new Error(&#x27;test&#x27;);
function untilExcept(buffer) {
  throw errTest;
}
const promise = readUntil(input, untilExcept);
input.write(inputData);
return promise.then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
    assert.strictEqual(err.read, undefined);
    assert.deepEqual(input.read(), inputData);
  }
);</code></pre></dd>
                <dt>rejects with TypeError for non-function until</dt>
                <dd><pre><code>const input = new PassThrough();
const promise = readUntil(input, true).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TypeError&#x27;);
  }
);
return promise;</code></pre></dd>
                <dt>does not cause unhandledRejection for non-function</dt>
                <dd><pre><code>const input = new PassThrough();
const immID = setImmediate(done);
process.once(&#x27;unhandledRejection&#x27;, () =&#x3E; {
  clearImmediate(immID);
  done(new Error(&#x27;unhandledRejection&#x27;));
});
readUntil(input, true).then(
  sinon.mock().never(),
  (err) =&#x3E; {
    assert.strictEqual(err.name, &#x27;TypeError&#x27;);
  }
);</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
  </div><!-- .container -->

  <script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/2.2.1/jquery.min.js"></script>
  <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/highlight.js/9.1.0/highlight.min.js"></script>
  <script type="text/javascript">//<![CDATA[
'use strict';
// Adjust the nested heading level to match depth
$('section section h1').each(function() {
  var $this = $(this);
  var depth = Math.min($this.parents('section').length, 6);
  // http://stackoverflow.com/a/30059450/503410
  $this.wrapInner(document.createElement('h' + depth)).children().unwrap();
});

// Make the tests collapsible
var testNum = 0;
$('dt + dd')
  .addClass('collapse')
  .attr('role', 'tabpanel')
  .attr('aria-expanded', 'false')
  .each(function() {
    var $this = $(this);
    var $dt = $this.prev();

    ++testNum;
    var id = 'test' + testNum;
    var idDt = id + '-title';
    var idDd = id + '-desc';

    $dt.attr('id', idDt);
    $this.attr('id', idDd);

    $dt.wrapInner('<a role="button" data-toggle="collapse" href="#' + idDd +
        '" aria-expanded="false" aria-controls="' + idDd + '"></a>')
      .children()
      .collapse();
  });

// Enable syntax highlighting for the code (which is all JavaScript)
hljs.configure({languages: ['javascript']});
hljs.initHighlighting();
//]]></script>
</body>
</html>
