<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Specifications in Mocha</title>
  <meta name="generator" content="Mocha &lt;https://mochajs.org/&gt;" />
  <meta name="license" content="MIT" />
  <meta name="copyright" content="&#169; 2016 Kevin Locke &lt;kevin@kevinlocke.name&gt;" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/highlight.js/9.1.0/styles/github.min.css" />
  <style type="text/css">
section section {
  margin-left: 1em;
}
section section section section {
  margin-left: 0;
}
  </style>
</head>
<body>
  <div class="container">
    <section class="suite">
      <h1>promisedRead</h1>
      <dl>
        <dt>has proper sync/async when loaded after yaku</dt>
        <dd><pre><code>fork('./test-bin/after-yaku-ok')
  .on('error', done)
  .on('exit', function(code) {
    assert.strictEqual(code, 0);
    done();
  });</code></pre></dd>
        <dt>has proper sync/async when loaded before yaku</dt>
        <dd><pre><code>fork('./test-bin/before-yaku-ok')
  .on('error', done)
  .on('exit', function(code) {
    assert.strictEqual(code, 0);
    done();
  });</code></pre></dd>
        <section class="suite">
          <h1>with pre-0.10 streams</h1>
          <dl>
            <section class="suite">
              <h1>.read()</h1>
              <dl>
                <dt>returns a Promise with read data</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
process.nextTick(function() {
  input.write(inputData);
});
return read(input).then(function(data) {
  assert.deepEqual(data, inputData);
});</code></pre></dd>
                <dt>returns a Promise with read object</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = {};
input.write(inputData);
return read(input).then(function(data) {
  assert.deepEqual(data, inputData);
});</code></pre></dd>
                <dt>can read a chunk larger than writes</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, 8).then(function(data) {
  assert.deepEqual(data, Buffer.concat([inputData, inputData]));
});
input.write(inputData);
process.nextTick(function() {
  input.write(inputData);
});
return promise;</code></pre></dd>
                <dt>can't read a chunk smaller than writes</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, 2).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>can read a chunk smaller than writes w/ .unshift()</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
input.unshift = function(chunk) {
  assert.deepEqual(chunk, inputData.slice(2));
};
var promise = read(input, 2).then(function(data) {
  assert.deepEqual(data, inputData.slice(0, 2));
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads a larger chunk if unshift emits error</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = function(chunk) {
  this.emit('error', new Error('test'));
};
var inputData = new Buffer('test');
var promise = read(input, 2).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads a larger chunk if unshift throws error</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = function(chunk) {
  throw new Error('test');
};
var inputData = new Buffer('test');
var promise = read(input, 2).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>does not expose unshift errors</dt>
                <dd><pre><code>var input = new PassThrough();
input.on('error', done);
input.unshift = function(chunk) {
  this.emit('error', new Error('test'));
};
var inputData = new Buffer('test');
read(input, 2).then(
  function(data) {
    assert.deepEqual(data, inputData);
    done();
  },
  done
);
input.write(inputData);</code></pre></dd>
                <dt>can short-read due to end</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, 8).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
process.nextTick(function() {
  input.end();
});
return promise;</code></pre></dd>
                <dt>can read an empty Array in objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [];
var promise = read(input).then(function(data) {
  assert.strictEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads at most one non-Buffer/string</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [1, 2, 3];
var promise = read(input, 2).then(function(data) {
  assert.strictEqual(data, inputData[0]);
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>reads at most one Buffer/string if options.objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [new Buffer('Larry'), new Buffer('Curly')];
var promise = read(input, 2, {objectMode: true}).then(function(data) {
  assert.strictEqual(data, inputData[0]);
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>resolves with null when no data is read</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = read(input).then(function(data) {
  assert.strictEqual(data, null);
});
input.end();
return promise;</code></pre></dd>
                <dt>does not resolve with null for null 'data' event</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = new Buffer('test');
var promise = read(input).then(function(data) {
  assert.strictEqual(data, inputData);
});
input.write(null);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>rejects with stream error</dt>
                <dd><pre><code>var input = new PassThrough();
var errTest = new Error('test');
var promise = read(input).then(
  sinon.mock().never(),
  function(err) { assert.strictEqual(err, errTest); }
);
input.emit('error', errTest);
return promise;</code></pre></dd>
                <dt>sets previously read data as .read on error</dt>
                <dd><pre><code>var input = new PassThrough();
var errTest = new Error('test');
var inputData = new Buffer('test');
var promise = read(input, 8).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err, errTest);
    assert.deepEqual(err.read, inputData);
  }
);
input.write(inputData, function() {
  input.emit('error', errTest);
});
return promise;</code></pre></dd>
                <dt>read(0) resolves to null</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var spy = input.read &amp;&amp; sinon.spy(input, 'read');
var promise = read(input, readArg).then(function(data) {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(-1) resolves to null</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var spy = input.read &amp;&amp; sinon.spy(input, 'read');
var promise = read(input, readArg).then(function(data) {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(false) resolves to null</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var spy = input.read &amp;&amp; sinon.spy(input, 'read');
var promise = read(input, readArg).then(function(data) {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(undefined) resolves to data</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var spy = input.read &amp;&amp; sinon.spy(input, 'read');
var promise = read(input, readArg).then(function(data) {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(null) resolves to data</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var spy = input.read &amp;&amp; sinon.spy(input, 'read');
var promise = read(input, readArg).then(function(data) {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(true) resolves to data</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var spy = input.read &amp;&amp; sinon.spy(input, 'read');
var promise = read(input, readArg).then(function(data) {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>does not lose sequential writes</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('Larry\n'),
  new Buffer('Curly\n'),
  new Buffer('Moe\n')
];
var readData = [];
function readAll(readable) {
  return read(input, 2).then(function(data) {
    if (data) {
      readData.push(data);
      return readAll(readable);
    }
    return Buffer.concat(readData);
  });
}
var promise = readAll(input).then(function(result) {
  assert.deepEqual(result, Buffer.concat(inputData));
});
inputData.forEach(function(data) {
  input.write(data);
});
input.end();
return promise;</code></pre></dd>
                <dt>does not lose consecutive synchronous writes</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('Larry\n'),
  new Buffer('Curly\n'),
  new Buffer('Moe\n')
];
var readData = [];
function readAll(readable) {
  return read(input, 2).then(function(data) {
    if (data) {
      readData.push(data);
      return readAll(readable);
    }
    return Buffer.concat(readData);
  });
}
var promise = readAll(input).then(function(result) {
  assert.deepEqual(result, Buffer.concat(inputData));
});
inputData.forEach(function(data) {
  input.emit('data', data);
});
input.emit('end');
return promise;</code></pre></dd>
                <dt>returns an instance of options.Promise</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = read(input, {Promise: BBPromise});
assert(promise instanceof BBPromise);</code></pre></dd>
                <dt>does not have .abortRead or .cancelRead by default</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = read(input);
assert.strictEqual(promise.abortRead, undefined);
assert.strictEqual(promise.cancelRead, undefined);</code></pre></dd>
                <dt>supports bluebird 3.x cancellation</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, {Promise: BBPromise}).then(
  function() {
    done(new Error('then should not be called'));
  },
  function() {
    done(new Error('catch should not be called'));
  }
);
promise.cancel();
// Delay so that onCancel is called before write
// See https://github.com/petkaantonov/bluebird/issues/1041
setImmediate(function() {
  input.write(inputData);
  // Delay long enough to ensure mocks are not called
  setImmediate(function() {
    if (input.read) {
      assert.deepEqual(input.read(), inputData);
    }
    done();
  });
});</code></pre></dd>
                <dt>supports bluebird timeout with cancellation</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
read(input, {Promise: BBPromise})
  .timeout(2)
  .then(
    function() {
      done(new Error('then should not be called'));
    },
    function(err) {
      assert.strictEqual(err.name, 'TimeoutError');
      if (input.read) {
        // Delay so that onCancel is called before write
        // See https://github.com/petkaantonov/bluebird/issues/1041
        setImmediate(function() {
          input.write(inputData);
          setImmediate(function() {
            assert.deepEqual(input.read(), inputData);
            done();
          });
        });
      } else {
        done();
      }
    }
  );</code></pre></dd>
                <section class="suite">
                  <h1>with options.cancellable</h1>
                  <dl>
                    <dt>has .abortRead and .cancelRead methods</dt>
                    <dd><pre><code>var input = new PassThrough();
var promise = read(input, {cancellable: true});
assert.strictEqual(typeof promise.abortRead, 'function');
assert.strictEqual(typeof promise.cancelRead, 'function');</code></pre></dd>
                    <dt>supports .cancelable as an alias</dt>
                    <dd><pre><code>var input = new PassThrough();
var promise = read(input, {cancelable: true});
assert.strictEqual(typeof promise.abortRead, 'function');
assert.strictEqual(typeof promise.cancelRead, 'function');</code></pre></dd>
                    <dt>rejects with AbortError on .abortRead</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, {cancellable: true});
promise.then(
  function() {
    done(new Error('then should not be called'));
  },
  function(err) {
    try {
      assert.strictEqual(err.name, 'AbortError');
    } catch (errAssert) {
      done(errAssert);
    }
  }
);
promise.abortRead();
input.write(inputData);
// Delay long enough to ensure data is not read
setImmediate(function() {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                    <dt>does not resolve, reject, or read after .cancelRead</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, {cancellable: true});
promise.then(
  function() {
    done(new Error('then should not be called'));
  },
  function() {
    done(new Error('catch should not be called'));
  }
);
promise.cancelRead();
input.write(inputData);
// Delay long enough to ensure mocks are not called
setImmediate(function() {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                    <dt>does nothing on .abortRead after .cancelRead</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, {cancellable: true});
promise.then(
  function() {
    done(new Error('then should not be called'));
  },
  function() {
    done(new Error('catch should not be called'));
  }
);
promise.cancelRead();
promise.abortRead();
input.write(inputData);
// Delay long enough to ensure mocks are not called
setImmediate(function() {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                    <dt>does nothing on .cancelRead after .abortRead</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, {cancellable: true});
promise.then(
  function() {
    done(new Error('then should not be called'));
  },
  function(err) {
    try {
      assert.strictEqual(err.name, 'AbortError');
    } catch (errAssert) {
      done(errAssert);
    }
  }
);
promise.abortRead();
promise.cancelRead();
input.write(inputData);
// Delay long enough to ensure mocks are not called
setImmediate(function() {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>with options.timeout</h1>
                  <dl>
                    <dt>rejects with TimeoutError after timeout ms</dt>
                    <dd><pre><code>var input = new PassThrough();
return read(input, {timeout: 1}).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TimeoutError');
  }
);</code></pre></dd>
                    <dt>passes options.timeout of 0 to setTimeout</dt>
                    <dd><pre><code>var input = new PassThrough();
var spy = sinon.spy(global, 'setTimeout');
var promise = read(input, {timeout: 0}).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TimeoutError');
  }
);
setTimeout.restore();
assert.strictEqual(spy.callCount, 1);
assert.strictEqual(spy.firstCall.args[1], 0);
return promise;</code></pre></dd>
                    <dt>resolves if read completes before timeout ms</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
read(input, {timeout: 1}).then(function(data) {
  assert.deepEqual(data, inputData);
  // Wait until after timeout to catch unhandled error
  setTimeout(done, 2);
}, done);
input.write(inputData);</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>.readTo()</h1>
              <dl>
                <dt>reads up to (and including) the marker</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('Larry\n');
var promise = readTo(input, new Buffer('\n')).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) the marker with encoding</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = 'Larry\n';
var promise = readTo(input, '\n').then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) the marker in objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = 3;
var promise = readTo(input, 3).then(function(data) {
  // Note:  readTo result is always an Array in objectMode
  assert.deepEqual(data, [inputData]);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to the marker across writes</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('La'),
  new Buffer('rry\n')
];
var promise = readTo(input, new Buffer('\n')).then(function(data) {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>reads up to the marker across writes with encoding</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = [
  'La',
  'rry\n'
];
var promise = readTo(input, '\n').then(function(data) {
  assert.deepEqual(data, inputData.join(''));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>reads up to the marker across writes in objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [1, 2, 3];
var promise = readTo(input, 3).then(function(data) {
  assert.deepEqual(data, inputData);
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>does strict equality checks for marker in objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
// Note:  null and undefined are not supported by stream.PassThrough
var inputData = [true, 0, '', false];
var promise = readTo(input, false).then(function(data) {
  assert.deepEqual(data, inputData);
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>reads up to the marker split across writes with encoding</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = [
  'Larry\n',
  'Cur',
  'ly\n',
  'Moe\n'
];
var promise = readTo(input, 'Curly\n').then(function(data) {
  assert.deepEqual(data, inputData.slice(0, 3).join(''));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>may return data after the marker w/o .unshift</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = undefined;
var inputData = new Buffer('Larry\nCurly');
var promise = readTo(input, '\n').then(function(data) {
  assert.deepEqual(data, inputData.slice(0, data.length));
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>does not read past the marker in objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [1, 2, 3, 4, 5];
var promise = readTo(input, 3).then(function(data) {
  var afterMarker = inputData.indexOf(3) + 1;
  assert.deepEqual(data, inputData.slice(0, afterMarker));
  if (input.read) {
    var expectData = inputData.slice(afterMarker);
    while (expectData.length &gt; 0) {
      assert.deepEqual(input.read(), expectData.shift());
    }
  }
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>stops reading after first write for 0-length marker</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = undefined;
var inputData = [
  new Buffer('Larry\n'),
  new Buffer('Curly\n'),
  new Buffer('Moe\n')
];
var promise = readTo(input, '').then(function(data) {
  assert.deepEqual(data, Buffer.concat(inputData).slice(0, data.length));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>treats strings as objects if options.objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = ['Larry', 'Curly', 'Moe'];
var promise = readTo(input, 'Moe', {objectMode: true})
  .then(function(data) {
    assert.deepEqual(data, inputData);
  });
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>can recognize objectMode late</dt>
                <dd><pre><code>// readTo expects a stream of Buffer objects until it reads a string
// at which point it realizes the stream is in objectMode and must
// recover gracefully.
var input = new PassThrough({objectMode: true});
var inputData = [new Buffer('test1'), 'test2'];
var promise = readTo(input, inputData[1]).then(function(data) {
  assert.deepEqual(data, inputData);
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>can read null from 'data' events</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var promise = readTo(input, null).then(function(data) {
  assert(Array.isArray(data));
  assert.strictEqual(data.length, 1);
  assert.strictEqual(data[0], null);
});
input.write(null);
return promise;</code></pre></dd>
                <dt>sets previously read data as .read on error</dt>
                <dd><pre><code>var input = new PassThrough();
var errTest = new Error('test');
var inputData = new Buffer('test');
var promise = readTo(input, '\n').then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err, errTest);
    assert.deepEqual(err.read, inputData);
  }
);
input.write(inputData, function() {
  input.emit('error', errTest);
});
return promise;</code></pre></dd>
                <dt>rejects with EOFError when no data is read</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = readTo(input, '\n').then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'EOFError');
  }
);
input.end();
return promise;</code></pre></dd>
                <dt>sets previously read data as .read on EOFError</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = readTo(input, '\n').then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'EOFError');
    assert.deepEqual(err.read, inputData);
  }
);
input.end(inputData);
return promise;</code></pre></dd>
                <dt>resolves with null when no data if options.endOK</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = readTo(input, '\n', {endOK: true}).then(function(data) {
  assert.strictEqual(data, null);
});
input.end();
return promise;</code></pre></dd>
                <dt>resolves with data previously read data if options.endOK</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = readTo(input, '\n', {endOK: true}).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.end(inputData);
return promise;</code></pre></dd>
                <dt>without unshift, sets read data as .read on .abortRead</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = undefined;
var inputData = new Buffer('test');
var promise = readTo(input, '\n', {cancellable: true});
input.write(inputData);
process.nextTick(function() {
  promise.abortRead();
});
return promise.then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'AbortError');
    assert.deepEqual(err.read, inputData);
  }
);</code></pre></dd>
                <dt>without unshift, returns read data from .cancelRead</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = undefined;
var inputData = new Buffer('test');
var promise = readTo(input, '\n', {cancellable: true});
input.write(inputData);
process.nextTick(function() {
  assert.deepEqual(promise.cancelRead(), inputData);
  done();
});</code></pre></dd>
                <dt>without unshift, sets read data as .read on timeout</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = undefined;
var inputData = new Buffer('test');
var promise = readTo(input, '\n', {timeout: 1});
input.write(inputData);
return promise.then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TimeoutError');
    assert.deepEqual(err.read, inputData);
  }
);</code></pre></dd>
                <section class="suite">
                  <h1>uses result indexOf conversions</h1>
                  <dl>
                    <dt>string marker in Buffer</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('Larry\n');
var promise = readTo(input, '\n').then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                    <dt>character code marker in Buffer</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('Larry\n');
var promise = readTo(input, '\n'.charCodeAt(0)).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                    <dt>Buffer marker in string</dt>
                    <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = 'Larry\n';
var promise = readTo(input, new Buffer('\n')).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                    <dt>rejects with TypeError on type mismatch</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('Larry\n');
var promise = readTo(input, true).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TypeError');
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>.readToEnd()</h1>
              <dl>
                <dt>reads to stream end</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('Larry\n'),
  new Buffer('Curly\n'),
  new Buffer('Moe\n')
];
var promise = readToEnd(input).then(function(data) {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData, input.end.bind(input));
return promise;</code></pre></dd>
                <dt>reads to stream end (encoded)</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = [
  'Larry\n',
  'Curly\n',
  'Moe\n'
];
var promise = readToEnd(input).then(function(data) {
  assert.deepEqual(data, inputData.join(''));
});
writeEachTo(input, inputData, input.end.bind(input));
return promise;</code></pre></dd>
                <dt>reads to stream end (objectMode)</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [0, 1, 2, 3, 4];
var promise = readToEnd(input).then(function(data) {
  assert.deepEqual(data, inputData);
});
writeEachTo(input, inputData, input.end.bind(input));
return promise;</code></pre></dd>
                <dt>resolves with null when no data</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = readToEnd(input).then(function(data) {
  assert.strictEqual(data, null);
});
input.end();
return promise;</code></pre></dd>
                <dt>rejects with stream error</dt>
                <dd><pre><code>var input = new PassThrough();
var errTest = new Error('test');
var promise = readToEnd(input).then(
  sinon.mock().never(),
  function(err) { assert.strictEqual(err, errTest); }
);
input.emit('error', errTest);
return promise;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>.readToMatch()</h1>
              <dl>
                <dt>reads up to (and including) a RegExp</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = 'Larry\n';
var promise = readToMatch(input, /\n/g).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) a non-global RegExp</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = 'Larry\n';
var promise = readToMatch(input, /\n/).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) a string expression</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = 'Larry\n';
var promise = readToMatch(input, '\n').then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) a match split across writes</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = [
  'Larry\n',
  'Cur',
  'ly\n',
  'Moe\n'
];
var promise = readToMatch(input, /Curly\n/g).then(function(data) {
  assert.deepEqual(data, inputData.slice(0, 3).join(''));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>optimizes search from options.maxMatchLen</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = [
  'Larry\n',
  'Cur',
  'ly\n',
  'Moe\n'
];
var regexp = /Curly\n/g;
var options = {maxMatchLen: 6};
// Note:  We could spy on writes to .lastIndex of regexp, but this would
// rely too much on implementation details (of readToMatch and RegExp).
// Instead, this tests it doesn't hurt and coverage shows the codepath.
var promise = readToMatch(input, regexp, options).then(function(data) {
  assert.deepEqual(data, inputData.slice(0, 3).join(''));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>rejects with SyntaxError for invalid string expressions</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
return readToMatch(input, '*').then(
    sinon.mock().never(),
    function(err) {
      assert.strictEqual(err.name, 'SyntaxError');
    }
);</code></pre></dd>
                <dt>rejects with TypeError for non-string streams</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('Larry\n');
var promise = readToMatch(input, /\n/g).then(
    sinon.mock().never(),
    function(err) {
      assert.strictEqual(err.name, 'TypeError');
    }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>resolves with null when no data if options.endOK</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = readToMatch(input, /\n/g, {endOK: true})
  .then(function(data) {
    assert.strictEqual(data, null);
  });
input.end();
return promise;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>.readUntil()</h1>
              <dl>
                <dt>continues reading when negative or non-numeric falsey</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [0, 1, 2, 3, 4];
var callNum = 0;
var returnValues = [undefined, null, false, -5, true];
function until(buffer, chunk) {
  assert(Array.isArray(buffer));
  assert(typeof chunk === 'number');
  return returnValues[callNum++];
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, inputData);
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>stops reading on true</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
function until(buffer, chunk) {
  return true;
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>stops reading if matches length</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
function until(buffer, chunk) {
  return buffer.length;
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>stops reading if less than length</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
function until(buffer, chunk) {
  return 2;
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>stops reading on 0</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
function until(buffer, chunk) {
  return 0;
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads to length greater than current buffer</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('test1'),
  new Buffer('test2')
];
function until(buffer, chunk) {
  return inputData[0].length + inputData[1].length;
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>rejects with TypeError for non-numeric/non-boolean</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
function until(buffer, chunk) {
  return {};
}
var promise = readUntil(input, until).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TypeError');
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>calls the until function on each read</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('Larry\n'),
  new Buffer('Curly\n'),
  new Buffer('Moe\n')
];
var spy = sinon.spy(function until(buffer, chunk) {
  assert(buffer instanceof Buffer);
  assert(chunk instanceof Buffer);
  // Note:  No Buffer.equals before Node v0.11.13
  return String(chunk) === String(inputData[inputData.length - 1]);
});
var promise = readUntil(input, spy).then(function(data) {
  assert.deepEqual(data, Buffer.concat(inputData));
  assert.strictEqual(spy.callCount, 3);
  spy.getCall(0).calledWithExactly(inputData[0], inputData[0]);
  spy.getCall(1).calledWithExactly(
    Buffer.concat(inputData.slice(0, 2)),
    inputData[1]
  );
  spy.getCall(2).calledWithExactly(
    Buffer.concat(inputData),
    inputData[2]
  );
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>can handle unexpectedly large reads</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('Larry\n'),
  new Buffer(512)
];
inputData[1].fill(0);
var bigInputData = new Buffer(4 * 1024);
for (var i = 0; i &lt; bigInputData.length; ++i) {
  bigInputData[i] = i % 256;
}
inputData.push(bigInputData);
// TODO:  Some way to test buffer is a slice of a much larger buffer?
function untilBig(buffer, chunk) {
  return chunk.length === bigInputData.length;
}
var promise = readUntil(input, untilBig).then(function(data) {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>treats Buffers as objects if options.objectMode</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('Larry\n'),
  new Buffer('Curly\n'),
  new Buffer('Moe\n')
];
function until(buffer) {
  assert(Array.isArray(buffer));
  return buffer.length &lt; 2 ? -1 : 2;
}
var promise = readUntil(input, until, {objectMode: true})
  .then(function(data) {
    assert.deepEqual(data, inputData.slice(0, 2));
  });
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>does not combine Arrays in objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [['a'], ['b'], []];
function untilEmpty(arrays) {
  assert(arrays.every(Array.isArray));
  return arrays[arrays.length - 1].length === 0 ? arrays.length : -1;
}
var promise = readUntil(input, untilEmpty).then(function(data) {
  assert.strictEqual(data.length, inputData.length);
  data.forEach(function(array, i) {
    assert.strictEqual(array, inputData[i]);
  });
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>rejects with EOFError when no data is read</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = readUntil(input, untilNever).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'EOFError');
  }
);
input.end();
return promise;</code></pre></dd>
                <dt>sets previously read data as .read on EOFError</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = readUntil(input, untilNever).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'EOFError');
    assert.deepEqual(err.read, inputData);
  }
);
input.end(inputData);
return promise;</code></pre></dd>
                <dt>rejects with an Error thrown by until</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var errTest = new Error('test');
function untilExcept(buffer) {
  throw errTest;
}
var promise = readUntil(input, untilExcept).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err, errTest);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>rejects with a falsey value thrown by until</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var errTest = null;
function untilExcept(buffer) {
  throw errTest;
}
var promise = readUntil(input, untilExcept).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err, errTest);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>without unshift, sets read data as .read on exception</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = undefined;
var inputData = new Buffer('test');
var errTest = new Error('test');
function untilExcept(buffer) {
  throw errTest;
}
var promise = readUntil(input, untilExcept);
input.write(inputData);
return promise.then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err, errTest);
    assert.deepEqual(err.read, inputData);
  }
);</code></pre></dd>
                <dt>rejects with TypeError for non-function until</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = readUntil(input, true).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TypeError');
  }
);
return promise;</code></pre></dd>
                <dt>does not cause unhandledRejection for non-function</dt>
                <dd><pre><code>var input = new PassThrough();
var immID = setImmediate(done);
process.once('unhandledRejection', function() {
  clearImmediate(immID);
  done(new Error('unhandledRejection'));
});
readUntil(input, true).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TypeError');
  }
);</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>with 0.10 streams</h1>
          <dl>
            <section class="suite">
              <h1>.read()</h1>
              <dl>
                <dt>returns a Promise with read data</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
process.nextTick(function() {
  input.write(inputData);
});
return read(input).then(function(data) {
  assert.deepEqual(data, inputData);
});</code></pre></dd>
                <dt>returns a Promise with read object</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = {};
input.write(inputData);
return read(input).then(function(data) {
  assert.deepEqual(data, inputData);
});</code></pre></dd>
                <dt>returns a Promise with available data</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
input.write(inputData);
process.nextTick(function() {
  read(input).then(
    function(data) {
      assert.deepEqual(data, inputData);
      done();
    },
    done
  );
});</code></pre></dd>
                <dt>can read a chunk larger than writes</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, 8).then(function(data) {
  assert.deepEqual(data, Buffer.concat([inputData, inputData]));
});
input.write(inputData);
process.nextTick(function() {
  input.write(inputData);
});
return promise;</code></pre></dd>
                <dt>can read a chunk smaller than writes</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, 2).then(function(data) {
  assert.deepEqual(data, inputData.slice(0, 2));
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>can short-read due to end</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, 8).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
process.nextTick(function() {
  input.end();
});
return promise;</code></pre></dd>
                <dt>can read an empty Array in objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [];
var promise = read(input).then(function(data) {
  assert.strictEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads at most one non-Buffer/string</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [1, 2, 3];
var promise = read(input, 2).then(function(data) {
  assert.strictEqual(data, inputData[0]);
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>reads at most one Buffer/string if options.objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [new Buffer('Larry'), new Buffer('Curly')];
var promise = read(input, 2, {objectMode: true}).then(function(data) {
  assert.strictEqual(data, inputData[0]);
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>resolves with null when no data is read</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = read(input).then(function(data) {
  assert.strictEqual(data, null);
});
input.end();
return promise;</code></pre></dd>
                <dt>resolves with null after end for stream.Readable</dt>
                <dd><pre><code>// This only works for proper instances of stream.Readable and is not
// guaranteed to work (due to use of Readable implementation details).
var input = new PassThrough();
input.once('end', function() {
  process.nextTick(function() {
    read(input).then(function(data) {
      assert.strictEqual(data, null);
    }).then(done, done);
  });
});
input.end();
// Note:  Must read after .end() for 'end' to be emitted
input.read();</code></pre></dd>
                <dt>rejects with stream error</dt>
                <dd><pre><code>var input = new PassThrough();
var errTest = new Error('test');
var promise = read(input).then(
  sinon.mock().never(),
  function(err) { assert.strictEqual(err, errTest); }
);
input.emit('error', errTest);
return promise;</code></pre></dd>
                <dt>does not read after error</dt>
                <dd><pre><code>var input = new PassThrough();
var errTest = new Error('test');
var promise = read(input).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err, errTest);
    assert.notEqual(input.read(), null);
  }
);
input.emit('error', errTest);
input.write('data');
return promise;</code></pre></dd>
                <dt>read(0) calls .read and resolves to null</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var spy = input.read &amp;&amp; sinon.spy(input, 'read');
var promise = read(input, readArg).then(function(data) {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(-1) calls .read and resolves to null</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var spy = input.read &amp;&amp; sinon.spy(input, 'read');
var promise = read(input, readArg).then(function(data) {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(false) calls .read and resolves to null</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var spy = input.read &amp;&amp; sinon.spy(input, 'read');
var promise = read(input, readArg).then(function(data) {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(undefined) calls .read and resolves to data</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var spy = input.read &amp;&amp; sinon.spy(input, 'read');
var promise = read(input, readArg).then(function(data) {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(null) calls .read and resolves to data</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var spy = input.read &amp;&amp; sinon.spy(input, 'read');
var promise = read(input, readArg).then(function(data) {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>read(true) calls .read and resolves to data</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var spy = input.read &amp;&amp; sinon.spy(input, 'read');
var promise = read(input, readArg).then(function(data) {
  if (readsData) {
    assert.notEqual(data, null);
  } else {
    assert.strictEqual(data, null);
  }
  if (spy) {
    assert(spy.firstCall.calledWithExactly(readArg));
  }
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>can pass an object argument to .read with options</dt>
                <dd><pre><code>var input = new PassThrough();
var readArg = {};
var mock = sinon.mock(input)
  .expects('read')
    .once()
    .withExactArgs(readArg);
read(input, readArg, {});
mock.verify();</code></pre></dd>
                <dt>does not lose sequential writes</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('Larry\n'),
  new Buffer('Curly\n'),
  new Buffer('Moe\n')
];
var readData = [];
function readAll(readable) {
  return read(input, 2).then(function(data) {
    if (data) {
      readData.push(data);
      return readAll(readable);
    }
    return Buffer.concat(readData);
  });
}
var promise = readAll(input).then(function(result) {
  assert.deepEqual(result, Buffer.concat(inputData));
});
inputData.forEach(function(data) {
  input.write(data);
});
input.end();
return promise;</code></pre></dd>
                <dt>returns an instance of options.Promise</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = read(input, {Promise: BBPromise});
assert(promise instanceof BBPromise);</code></pre></dd>
                <dt>does not have .abortRead or .cancelRead by default</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = read(input);
assert.strictEqual(promise.abortRead, undefined);
assert.strictEqual(promise.cancelRead, undefined);</code></pre></dd>
                <dt>supports bluebird 3.x cancellation</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, {Promise: BBPromise}).then(
  function() {
    done(new Error('then should not be called'));
  },
  function() {
    done(new Error('catch should not be called'));
  }
);
promise.cancel();
// Delay so that onCancel is called before write
// See https://github.com/petkaantonov/bluebird/issues/1041
setImmediate(function() {
  input.write(inputData);
  // Delay long enough to ensure mocks are not called
  setImmediate(function() {
    if (input.read) {
      assert.deepEqual(input.read(), inputData);
    }
    done();
  });
});</code></pre></dd>
                <dt>supports bluebird timeout with cancellation</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
read(input, {Promise: BBPromise})
  .timeout(2)
  .then(
    function() {
      done(new Error('then should not be called'));
    },
    function(err) {
      assert.strictEqual(err.name, 'TimeoutError');
      if (input.read) {
        // Delay so that onCancel is called before write
        // See https://github.com/petkaantonov/bluebird/issues/1041
        setImmediate(function() {
          input.write(inputData);
          setImmediate(function() {
            assert.deepEqual(input.read(), inputData);
            done();
          });
        });
      } else {
        done();
      }
    }
  );</code></pre></dd>
                <section class="suite">
                  <h1>with options.cancellable</h1>
                  <dl>
                    <dt>has .abortRead and .cancelRead methods</dt>
                    <dd><pre><code>var input = new PassThrough();
var promise = read(input, {cancellable: true});
assert.strictEqual(typeof promise.abortRead, 'function');
assert.strictEqual(typeof promise.cancelRead, 'function');</code></pre></dd>
                    <dt>supports .cancelable as an alias</dt>
                    <dd><pre><code>var input = new PassThrough();
var promise = read(input, {cancelable: true});
assert.strictEqual(typeof promise.abortRead, 'function');
assert.strictEqual(typeof promise.cancelRead, 'function');</code></pre></dd>
                    <dt>rejects with AbortError on .abortRead</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, {cancellable: true});
promise.then(
  function() {
    done(new Error('then should not be called'));
  },
  function(err) {
    try {
      assert.strictEqual(err.name, 'AbortError');
    } catch (errAssert) {
      done(errAssert);
    }
  }
);
promise.abortRead();
input.write(inputData);
// Delay long enough to ensure data is not read
setImmediate(function() {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                    <dt>does not resolve, reject, or read after .cancelRead</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, {cancellable: true});
promise.then(
  function() {
    done(new Error('then should not be called'));
  },
  function() {
    done(new Error('catch should not be called'));
  }
);
promise.cancelRead();
input.write(inputData);
// Delay long enough to ensure mocks are not called
setImmediate(function() {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                    <dt>does nothing on .abortRead after .cancelRead</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, {cancellable: true});
promise.then(
  function() {
    done(new Error('then should not be called'));
  },
  function() {
    done(new Error('catch should not be called'));
  }
);
promise.cancelRead();
promise.abortRead();
input.write(inputData);
// Delay long enough to ensure mocks are not called
setImmediate(function() {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                    <dt>does nothing on .cancelRead after .abortRead</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = read(input, {cancellable: true});
promise.then(
  function() {
    done(new Error('then should not be called'));
  },
  function(err) {
    try {
      assert.strictEqual(err.name, 'AbortError');
    } catch (errAssert) {
      done(errAssert);
    }
  }
);
promise.abortRead();
promise.cancelRead();
input.write(inputData);
// Delay long enough to ensure mocks are not called
setImmediate(function() {
  if (input.read) {
    assert.deepEqual(input.read(), inputData);
  }
  done();
});</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>with options.timeout</h1>
                  <dl>
                    <dt>rejects with TimeoutError after timeout ms</dt>
                    <dd><pre><code>var input = new PassThrough();
return read(input, {timeout: 1}).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TimeoutError');
  }
);</code></pre></dd>
                    <dt>passes options.timeout of 0 to setTimeout</dt>
                    <dd><pre><code>var input = new PassThrough();
var spy = sinon.spy(global, 'setTimeout');
var promise = read(input, {timeout: 0}).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TimeoutError');
  }
);
setTimeout.restore();
assert.strictEqual(spy.callCount, 1);
assert.strictEqual(spy.firstCall.args[1], 0);
return promise;</code></pre></dd>
                    <dt>does not read after timeout</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
read(input, {timeout: 1}).then(
  function() {
    done(new Error('then should not be called'));
  },
  function(err) {
    assert.strictEqual(err.name, 'TimeoutError');
    input.write(inputData);
    setImmediate(function() {
      assert.deepEqual(input.read(), inputData);
      done();
    });
  }
);</code></pre></dd>
                    <dt>resolves if read completes before timeout ms</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
read(input, {timeout: 1}).then(function(data) {
  assert.deepEqual(data, inputData);
  // Wait until after timeout to catch unhandled error
  setTimeout(done, 2);
}, done);
input.write(inputData);</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>.readTo()</h1>
              <dl>
                <dt>reads up to (and including) the marker</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('Larry\n');
var promise = readTo(input, new Buffer('\n')).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) the marker with encoding</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = 'Larry\n';
var promise = readTo(input, '\n').then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) the marker in objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = 3;
var promise = readTo(input, 3).then(function(data) {
  // Note:  readTo result is always an Array in objectMode
  assert.deepEqual(data, [inputData]);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to the marker across writes</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('La'),
  new Buffer('rry\n')
];
var promise = readTo(input, new Buffer('\n')).then(function(data) {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>reads up to the marker across writes with encoding</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = [
  'La',
  'rry\n'
];
var promise = readTo(input, '\n').then(function(data) {
  assert.deepEqual(data, inputData.join(''));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>reads up to the marker across writes in objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [1, 2, 3];
var promise = readTo(input, 3).then(function(data) {
  assert.deepEqual(data, inputData);
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>does strict equality checks for marker in objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
// Note:  null and undefined are not supported by stream.PassThrough
var inputData = [true, 0, '', false];
var promise = readTo(input, false).then(function(data) {
  assert.deepEqual(data, inputData);
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>reads up to the marker split across writes with encoding</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = [
  'Larry\n',
  'Cur',
  'ly\n',
  'Moe\n'
];
var promise = readTo(input, 'Curly\n').then(function(data) {
  assert.deepEqual(data, inputData.slice(0, 3).join(''));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>may return data after the marker w/o .unshift</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = undefined;
var inputData = new Buffer('Larry\nCurly');
var promise = readTo(input, '\n').then(function(data) {
  assert.deepEqual(data, inputData.slice(0, data.length));
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>does not read past the marker w/ .unshift</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('Larry\nCurly');
var promise = readTo(input, '\n').then(function(data) {
  var afterMarker = String(inputData).indexOf('\n') + 1;
  assert.deepEqual(data, inputData.slice(0, afterMarker));
  assert.deepEqual(input.read(), inputData.slice(afterMarker));
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>does not read past the marker in objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [1, 2, 3, 4, 5];
var promise = readTo(input, 3).then(function(data) {
  var afterMarker = inputData.indexOf(3) + 1;
  assert.deepEqual(data, inputData.slice(0, afterMarker));
  if (input.read) {
    var expectData = inputData.slice(afterMarker);
    while (expectData.length &gt; 0) {
      assert.deepEqual(input.read(), expectData.shift());
    }
  }
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>stops reading after first write for 0-length marker</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = undefined;
var inputData = [
  new Buffer('Larry\n'),
  new Buffer('Curly\n'),
  new Buffer('Moe\n')
];
var promise = readTo(input, '').then(function(data) {
  assert.deepEqual(data, Buffer.concat(inputData).slice(0, data.length));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>returns empty Buffer for 0-length marker w/ unshift</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('Larry\n');
var promise = readTo(input, new Buffer(0)).then(function(data) {
  assert.deepEqual(data, new Buffer(0));
  assert.deepEqual(input.read(), inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>treats strings as objects if options.objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = ['Larry', 'Curly', 'Moe'];
var promise = readTo(input, 'Moe', {objectMode: true})
  .then(function(data) {
    assert.deepEqual(data, inputData);
  });
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>can recognize objectMode late</dt>
                <dd><pre><code>// readTo expects a stream of Buffer objects until it reads a string
// at which point it realizes the stream is in objectMode and must
// recover gracefully.
var input = new PassThrough({objectMode: true});
var inputData = [new Buffer('test1'), 'test2'];
var promise = readTo(input, inputData[1]).then(function(data) {
  assert.deepEqual(data, inputData);
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>sets previously read data as .read on error</dt>
                <dd><pre><code>var input = new PassThrough();
var errTest = new Error('test');
var inputData = new Buffer('test');
var promise = readTo(input, '\n').then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err, errTest);
    assert.deepEqual(err.read, inputData);
  }
);
input.write(inputData, function() {
  input.emit('error', errTest);
});
return promise;</code></pre></dd>
                <dt>rejects with EOFError when no data is read</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = readTo(input, '\n').then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'EOFError');
  }
);
input.end();
return promise;</code></pre></dd>
                <dt>sets previously read data as .read on EOFError</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = readTo(input, '\n').then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'EOFError');
    assert.deepEqual(err.read, inputData);
  }
);
input.end(inputData);
return promise;</code></pre></dd>
                <dt>resolves with null when no data if options.endOK</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = readTo(input, '\n', {endOK: true}).then(function(data) {
  assert.strictEqual(data, null);
});
input.end();
return promise;</code></pre></dd>
                <dt>resolves with data previously read data if options.endOK</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = readTo(input, '\n', {endOK: true}).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.end(inputData);
return promise;</code></pre></dd>
                <dt>without unshift, sets read data as .read on .abortRead</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = undefined;
var inputData = new Buffer('test');
var promise = readTo(input, '\n', {cancellable: true});
input.write(inputData);
process.nextTick(function() {
  promise.abortRead();
});
return promise.then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'AbortError');
    assert.deepEqual(err.read, inputData);
  }
);</code></pre></dd>
                <dt>without unshift, returns read data from .cancelRead</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = undefined;
var inputData = new Buffer('test');
var promise = readTo(input, '\n', {cancellable: true});
input.write(inputData);
process.nextTick(function() {
  assert.deepEqual(promise.cancelRead(), inputData);
  done();
});</code></pre></dd>
                <dt>without unshift, sets read data as .read on timeout</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = undefined;
var inputData = new Buffer('test');
var promise = readTo(input, '\n', {timeout: 1});
input.write(inputData);
return promise.then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TimeoutError');
    assert.deepEqual(err.read, inputData);
  }
);</code></pre></dd>
                <dt>with unshift, unshifts read data on .abortRead</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = readTo(input, '\n', {cancellable: true});
input.write(inputData);
process.nextTick(function() {
  promise.abortRead();
});
return promise.then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'AbortError');
    assert.strictEqual(err.read, undefined);
    assert.deepEqual(input.read(), inputData);
  }
);</code></pre></dd>
                <dt>with unshift, unshifts read data on .cancelRead</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = readTo(input, '\n', {cancellable: true});
input.write(inputData);
// Wait until data has been read
process.nextTick(function() {
  promise.cancelRead();
  assert.deepEqual(input.read(), inputData);
  done();
});</code></pre></dd>
                <dt>with unshift, unshifts read data on timeout</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = readTo(input, '\n', {timeout: 1});
input.write(inputData);
return promise.then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TimeoutError');
    assert.strictEqual(err.read, undefined);
    assert.deepEqual(input.read(), inputData);
  }
);</code></pre></dd>
                <section class="suite">
                  <h1>uses result indexOf conversions</h1>
                  <dl>
                    <dt>string marker in Buffer</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('Larry\n');
var promise = readTo(input, '\n').then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                    <dt>character code marker in Buffer</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('Larry\n');
var promise = readTo(input, '\n'.charCodeAt(0)).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                    <dt>Buffer marker in string</dt>
                    <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = 'Larry\n';
var promise = readTo(input, new Buffer('\n')).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                    <dt>rejects with TypeError on type mismatch</dt>
                    <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('Larry\n');
var promise = readTo(input, true).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TypeError');
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>.readToEnd()</h1>
              <dl>
                <dt>reads to stream end</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('Larry\n'),
  new Buffer('Curly\n'),
  new Buffer('Moe\n')
];
var promise = readToEnd(input).then(function(data) {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData, input.end.bind(input));
return promise;</code></pre></dd>
                <dt>reads to stream end (encoded)</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = [
  'Larry\n',
  'Curly\n',
  'Moe\n'
];
var promise = readToEnd(input).then(function(data) {
  assert.deepEqual(data, inputData.join(''));
});
writeEachTo(input, inputData, input.end.bind(input));
return promise;</code></pre></dd>
                <dt>reads to stream end (objectMode)</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [0, 1, 2, 3, 4];
var promise = readToEnd(input).then(function(data) {
  assert.deepEqual(data, inputData);
});
writeEachTo(input, inputData, input.end.bind(input));
return promise;</code></pre></dd>
                <dt>resolves with null when no data</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = readToEnd(input).then(function(data) {
  assert.strictEqual(data, null);
});
input.end();
return promise;</code></pre></dd>
                <dt>rejects with stream error</dt>
                <dd><pre><code>var input = new PassThrough();
var errTest = new Error('test');
var promise = readToEnd(input).then(
  sinon.mock().never(),
  function(err) { assert.strictEqual(err, errTest); }
);
input.emit('error', errTest);
return promise;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>.readToMatch()</h1>
              <dl>
                <dt>reads up to (and including) a RegExp</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = 'Larry\n';
var promise = readToMatch(input, /\n/g).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) a non-global RegExp</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = 'Larry\n';
var promise = readToMatch(input, /\n/).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) a string expression</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = 'Larry\n';
var promise = readToMatch(input, '\n').then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>reads up to (and including) a match split across writes</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = [
  'Larry\n',
  'Cur',
  'ly\n',
  'Moe\n'
];
var promise = readToMatch(input, /Curly\n/g).then(function(data) {
  assert.deepEqual(data, inputData.slice(0, 3).join(''));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>optimizes search from options.maxMatchLen</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
var inputData = [
  'Larry\n',
  'Cur',
  'ly\n',
  'Moe\n'
];
var regexp = /Curly\n/g;
var options = {maxMatchLen: 6};
// Note:  We could spy on writes to .lastIndex of regexp, but this would
// rely too much on implementation details (of readToMatch and RegExp).
// Instead, this tests it doesn't hurt and coverage shows the codepath.
var promise = readToMatch(input, regexp, options).then(function(data) {
  assert.deepEqual(data, inputData.slice(0, 3).join(''));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>rejects with SyntaxError for invalid string expressions</dt>
                <dd><pre><code>var input = new PassThrough({encoding: 'utf8'});
return readToMatch(input, '*').then(
    sinon.mock().never(),
    function(err) {
      assert.strictEqual(err.name, 'SyntaxError');
    }
);</code></pre></dd>
                <dt>rejects with TypeError for non-string streams</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('Larry\n');
var promise = readToMatch(input, /\n/g).then(
    sinon.mock().never(),
    function(err) {
      assert.strictEqual(err.name, 'TypeError');
    }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>resolves with null when no data if options.endOK</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = readToMatch(input, /\n/g, {endOK: true})
  .then(function(data) {
    assert.strictEqual(data, null);
  });
input.end();
return promise;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>.readUntil()</h1>
              <dl>
                <dt>continues reading when negative or non-numeric falsey</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [0, 1, 2, 3, 4];
var callNum = 0;
var returnValues = [undefined, null, false, -5, true];
function until(buffer, chunk) {
  assert(Array.isArray(buffer));
  assert(typeof chunk === 'number');
  return returnValues[callNum++];
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, inputData);
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>stops reading on true</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
function until(buffer, chunk) {
  return true;
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>stops reading if matches length</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
function until(buffer, chunk) {
  return buffer.length;
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>stops reading and unshifts if less than length</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
function until(buffer, chunk) {
  return 2;
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, inputData.slice(0, 2));
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>stops reading and unshifts for objectMode stream</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [0, 1, 2, 3, 4];
function until(buffer, chunk) {
  return buffer.length === inputData.length - 1 ? 2 : -1;
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, inputData.slice(0, 2));
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>stops reading and unshifts on 0</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
function until(buffer, chunk) {
  return 0;
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, new Buffer(0));
});
input.write(inputData);
return promise;</code></pre></dd>
                <dt>can not unshift once ended</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
function until(buffer, chunk, ended) {
  return ended ? 2 : -1;
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, inputData);
});
input.end(inputData);
return promise;</code></pre></dd>
                <dt>reads to length greater than current buffer</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('test1'),
  new Buffer('test2')
];
function until(buffer, chunk) {
  return inputData[0].length + inputData[1].length;
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>reads to exact length greater than current buffer</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = undefined;
var inputData = [
  new Buffer('test1'),
  new Buffer('test2')
];
function until(buffer, chunk) {
  return inputData[0].length + inputData[1].length - 2;
}
var promise = readUntil(input, until).then(function(data) {
  assert.deepEqual(data, Buffer.concat(inputData).slice(0, -2));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>rejects with TypeError for non-numeric/non-boolean</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
function until(buffer, chunk) {
  return {};
}
var promise = readUntil(input, until).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TypeError');
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>unshifts on TypeError due to non-numeric/non-boolean</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
function until(buffer, chunk) {
  return {};
}
var promise = readUntil(input, until).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TypeError');
    assert.deepEqual(input.read(), inputData);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>calls the until function on each read</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('Larry\n'),
  new Buffer('Curly\n'),
  new Buffer('Moe\n')
];
var spy = sinon.spy(function until(buffer, chunk) {
  assert(buffer instanceof Buffer);
  assert(chunk instanceof Buffer);
  // Note:  No Buffer.equals before Node v0.11.13
  return String(chunk) === String(inputData[inputData.length - 1]);
});
var promise = readUntil(input, spy).then(function(data) {
  assert.deepEqual(data, Buffer.concat(inputData));
  assert.strictEqual(spy.callCount, 3);
  spy.getCall(0).calledWithExactly(inputData[0], inputData[0]);
  spy.getCall(1).calledWithExactly(
    Buffer.concat(inputData.slice(0, 2)),
    inputData[1]
  );
  spy.getCall(2).calledWithExactly(
    Buffer.concat(inputData),
    inputData[2]
  );
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>can handle unexpectedly large reads</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('Larry\n'),
  new Buffer(512)
];
inputData[1].fill(0);
var bigInputData = new Buffer(4 * 1024);
for (var i = 0; i &lt; bigInputData.length; ++i) {
  bigInputData[i] = i % 256;
}
inputData.push(bigInputData);
// TODO:  Some way to test buffer is a slice of a much larger buffer?
function untilBig(buffer, chunk) {
  return chunk.length === bigInputData.length;
}
var promise = readUntil(input, untilBig).then(function(data) {
  assert.deepEqual(data, Buffer.concat(inputData));
});
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>treats Buffers as objects if options.objectMode</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = [
  new Buffer('Larry\n'),
  new Buffer('Curly\n'),
  new Buffer('Moe\n')
];
function until(buffer) {
  assert(Array.isArray(buffer));
  return buffer.length &lt; 2 ? -1 : 2;
}
var promise = readUntil(input, until, {objectMode: true})
  .then(function(data) {
    assert.deepEqual(data, inputData.slice(0, 2));
  });
writeEachTo(input, inputData);
return promise;</code></pre></dd>
                <dt>does not combine Arrays in objectMode</dt>
                <dd><pre><code>var input = new PassThrough({objectMode: true});
var inputData = [['a'], ['b'], []];
function untilEmpty(arrays) {
  assert(arrays.every(Array.isArray));
  return arrays[arrays.length - 1].length === 0 ? arrays.length : -1;
}
var promise = readUntil(input, untilEmpty).then(function(data) {
  assert.strictEqual(data.length, inputData.length);
  data.forEach(function(array, i) {
    assert.strictEqual(array, inputData[i]);
  });
});
inputData.forEach(function(data) {
  input.write(data);
});
return promise;</code></pre></dd>
                <dt>rejects with EOFError when no data is read</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = readUntil(input, untilNever).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'EOFError');
  }
);
input.end();
return promise;</code></pre></dd>
                <dt>sets previously read data as .read on EOFError</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var promise = readUntil(input, untilNever).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'EOFError');
    assert.deepEqual(err.read, inputData);
  }
);
input.end(inputData);
return promise;</code></pre></dd>
                <dt>rejects with EOFError after end for stream.Readable</dt>
                <dd><pre><code>// This only works for proper instances of stream.Readable and is not
// guaranteed to work (due to use of Readable implementation details).
var input = new PassThrough();
input.once('end', function() {
  process.nextTick(function() {
    readUntil(input, untilNever).then(
      sinon.mock().never(),
      function(err) {
        assert.strictEqual(err.name, 'EOFError');
      }
    ).then(done, done);
  });
});
input.end();
// Note:  Must read after .end() for 'end' to be emitted
input.read();</code></pre></dd>
                <dt>rejects with an Error thrown by until</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var errTest = new Error('test');
function untilExcept(buffer) {
  throw errTest;
}
var promise = readUntil(input, untilExcept).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err, errTest);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>rejects with a falsey value thrown by until</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var errTest = null;
function untilExcept(buffer) {
  throw errTest;
}
var promise = readUntil(input, untilExcept).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err, errTest);
  }
);
input.write(inputData);
return promise;</code></pre></dd>
                <dt>does not read after exception</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var inputData2 = new Buffer('test2');
var errTest = new Error('test');
function untilExcept(buffer) {
  throw errTest;
}
readUntil(input, untilExcept).then(
  function() {
    done(new Error('then should not be called'));
  },
  function(err) {
    assert.strictEqual(err, errTest);
    // Discard inputData, if it was unshifted
    input.read();
    input.write(inputData2);
    setImmediate(function() {
      assert.deepEqual(input.read(), inputData2);
      done();
    });
  }
);
input.write(inputData);</code></pre></dd>
                <dt>without unshift, sets read data as .read on exception</dt>
                <dd><pre><code>var input = new PassThrough();
input.unshift = undefined;
var inputData = new Buffer('test');
var errTest = new Error('test');
function untilExcept(buffer) {
  throw errTest;
}
var promise = readUntil(input, untilExcept);
input.write(inputData);
return promise.then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err, errTest);
    assert.deepEqual(err.read, inputData);
  }
);</code></pre></dd>
                <dt>with unshift, unshifts read data on exception</dt>
                <dd><pre><code>var input = new PassThrough();
var inputData = new Buffer('test');
var errTest = new Error('test');
function untilExcept(buffer) {
  throw errTest;
}
var promise = readUntil(input, untilExcept);
input.write(inputData);
return promise.then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err, errTest);
    assert.strictEqual(err.read, undefined);
    assert.deepEqual(input.read(), inputData);
  }
);</code></pre></dd>
                <dt>rejects with TypeError for non-function until</dt>
                <dd><pre><code>var input = new PassThrough();
var promise = readUntil(input, true).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TypeError');
  }
);
return promise;</code></pre></dd>
                <dt>does not cause unhandledRejection for non-function</dt>
                <dd><pre><code>var input = new PassThrough();
var immID = setImmediate(done);
process.once('unhandledRejection', function() {
  clearImmediate(immID);
  done(new Error('unhandledRejection'));
});
readUntil(input, true).then(
  sinon.mock().never(),
  function(err) {
    assert.strictEqual(err.name, 'TypeError');
  }
);</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
  </div><!-- .container -->

  <script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/2.2.1/jquery.min.js"></script>
  <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/highlight.js/9.1.0/highlight.min.js"></script>
  <script type="text/javascript">//<![CDATA[
'use strict';
// Adjust the nested heading level to match depth
$('section section h1').each(function() {
  var $this = $(this);
  var depth = Math.min($this.parents('section').length, 6);
  // http://stackoverflow.com/a/30059450/503410
  $this.wrapInner(document.createElement('h' + depth)).children().unwrap();
});

// Make the tests collapsible
var testNum = 0;
$('dt + dd')
  .addClass('collapse')
  .attr('role', 'tabpanel')
  .attr('aria-expanded', 'false')
  .each(function() {
    var $this = $(this);
    var $dt = $this.prev();

    ++testNum;
    var id = 'test' + testNum;
    var idDt = id + '-title';
    var idDd = id + '-desc';

    $dt.attr('id', idDt);
    $this.attr('id', idDd);

    $dt.wrapInner('<a role="button" data-toggle="collapse" href="#' + idDd +
        '" aria-expanded="false" aria-controls="' + idDd + '"></a>')
      .children()
      .collapse();
  });

// Enable syntax highlighting for the code (which is all JavaScript)
hljs.configure({languages: ['javascript']});
hljs.initHighlighting();
//]]></script>
</body>
</html>
